=========== MODULES ===================
The Java Platform Module System (JPMS) was introduced in Java 9 to group code at a higher level and tries to solve the problems that Java has been plagued with since the beginning. The main purpose of a module is to provide groups of related packages to offer a particular set of functionality to developers. It’s like a JAR file except a developer chooses which packages are accessible outside the module. Let’s look at what modules are and what problems they are designed to solve.

The Java Platform Module System includes the following:
A format for module JAR files
Partitioning of the JDK into modules
Additional command-line options for Java tools
=========================
A module is a group of one or more packages plus a special file called module-info .java.
----------------
the JUnit 4 testing library depends on the Hamcrest library for matching logic. 
===================
The Java Development Kit (JDK) is larger than 150 MB. Even the Java Runtime Environment (JRE) was pretty big when it was available as a separate download.
=======================
The Java Platform Module System allows developers to specify what modules they actually need. This makes it possible to create a smaller runtime image that is customized to what the application needs and nothing more. Users can run that image without having Java installed at all.
================================
A tool called jlink is used to create this runtime image. Luckily, you only need to know that custom smaller runtimes are possible.
In addition to the smaller scale package, this approach improves security. If you don’t use AWT and a security vulnerability is reported for AWT, applications that packaged a runtime image without AWT aren’t affected.
===============
Improved Performance
Since Java now knows which modules are required, it only needs to look at those at class loading time. This improves startup time for big programs and requires less memory to run.
==============
The Java Platform Module System prevents this scenario. A package is only allowed to be supplied by one module. No more unpleasant surprises about a package at runtime.
===========
key differences between a module-info file and a regular Java class:
The module-info file must be in the root directory of your module. Regular Java classes should be in packages.
The module-info file must use the keyword module instead of class, interface, or enum.
The module name follows the naming rules for package names. It often includes periods (.) in its name. Regular class and package names are not allowed to have dashes (-). Module names follow the same rule.
========================================
package zoo.animal.feeding;
 
public class Task {
   public static void main(String... args) {
      System.out.println("All fed!");
   }
}
Next comes the module-info.java file. This is the simplest possible one.


module zoo.animal.feeding {
}
===================== can be empty module and file
 it was legal to compile any empty file with a .java extension even before modules. The compiler sees there isn’t a class in there and exits without creating a .class file.
==================================
compiles all .java files in the feeding/zoo/animal/feeding/ directory as well as the module-info.java file. The compiled output (the .class files) will be placed inside the feeding directory, while the mods directory will be used to locate other module dependencies during compilation:

javac -p mods -d feeding feeding/zoo/animal/feeding/*.java feeding/module-info.java
jar -cvf mods/zoo.animal.feeding.jar -C feeding/ .
# jar: Java archiving tool
# -c: Create JAR
# -v: Verbose output (show process)
# -f mods/zoo.animal.feeding.jar: JAR output file
# -C feeding/: Change directory to feeding/
# .: Include all files from feeding/ directory in the JAR
======================================

// HippoBirthday.java
package zoo.animal.care.details;
import zoo.animal.feeding.*;
public class HippoBirthday {
   private Task task;
}
 
// Diet.java
package zoo.animal.care.medical;
public class Diet { }
This time the module-info.java file specifies three things.

1: module zoo.animal.care {
2:    exports zoo.animal.care.medical;
3:    requires zoo.animal.feeding;
4: }
==============================================
javac -p mods
   -d care
   care/zoo/animal/care/details/*.java
   care/zoo/animal/care/medical/*.java
   care/module-info.java

jar -cvf mods/zoo.animal.care.jar -C care/ .

======================================
exports, requires, provides, uses, and opens. Now would be a good time to mention that these keywords can appear in any order in the module-info file.  These “keywords” are only keywords inside a module-info .java file.
 In other files, like classes and interfaces, you are free to name your variable exports. These special keywords are called directives.
================================
module zoo.animal.talks {
   exports zoo.animal.talks.content to zoo.staff;
   exports zoo.animal.talks.media;
   exports zoo.animal.talks.schedule;
 
   requires zoo.animal.feeding;
   requires zoo.animal.care;
}
From the zoo.staff module, nothing has changed. However, no other modules would be allowed to access that package.
=======================
As you saw earlier in this chapter, requires moduleName specifies that the current module depends on moduleName. There’s also a requires transitive moduleName, which means that any module that requires this module will also depend on moduleName.
When you declare a module, you can specify its dependencies using the requires directive. If module A depends on module B, you would write requires B; in module A's module declaration.

However, sometimes you want the dependencies of B to be visible to any module that depends on A. This is where requires transitive comes in. If you declare requires transitive B; in module A, it means that A's consumers (modules that depend on A) will also automatically depend on B.
============
requires: Makes a dependency available only to the current module.
requires transitive: Makes a dependency available not only to the current module but also to any modules that depend on it.
===========
For the remaining three keywords (provides, uses, and opens), you only need to be aware they exist rather than understanding them in detail for the 1Z0-815 exam
=============
The provides keyword specifies that a class provides an implementation of a service. The topic of services is covered on the 1Z0-816 exam, so for now, you can just think of a service as a fancy interface. To use it, you supply the API and class name that implements the API:
provides zoo.staff.ZooApi with zoo.staff.ZooImpl
The uses keyword specifies that a module is relying on a service. To code it, you supply the API you want to call:
uses zoo.staff.ZooApi
=================================
Java allows callers to inspect and call code at runtime with a technique called reflection
This is a powerful approach that allows calling code that might not be available at compile time. It can even be used to subvert access control! 
Since reflection can be dangerous, the module system requires developers to explicitly allow reflection in the module-info if they want calling modules to be allowed to use it. Here are two examples:
opens zoo.animal.talks.schedule;
opens zoo.animal.talks.media to zoo.staff;
The first example allows any module using this one to use reflection. The second example only gives that privilege to the zoo.staff package.
=================================
The java command has three module-related options. One describes a module, another lists the available modules, and the third shows the module resolution logic.
==================================
Suppose you are given the zoo.animal.feeding module JAR file and want to know about its module structure. You could “unjar” it and open the module-info file. This would show you that the module exports one package and doesn’t require any modules.


module zoo.animal.feeding {
   exports zoo.animal.feeding;
}
However, there is an easier way. The java command now has an option to describe a module. The following two commands are equivalent:


java -p mods
   -d zoo.animal.feeding
 
java -p mods
   --describe-module zoo.animal.feeding
Each prints information about the module. For example, it might print this:


zoo.animal.feeding file:///absolutePath/mods/zoo.animal.feeding.jar
exports zoo.animal.feeding
requires java.base mandated
-d:  --describe-module.
-p:  --module-path
mods is the directory where compiled modules are stored.

!! NB !! ======================
java -p mods -d zoo.animal.feeding
java -p mods --describe-module zoo.animal.feeding
================================

are equivalent, and both will describe the zoo.animal.feeding module by searching for it in the mods directory.
output:
zoo.animal.feeding file:///absolutePath/mods/zoo.animal.feeding.jar
exports zoo.animal.feeding
requires java.base mandated
===============
The java.base module is special. It is automatically added as a dependency to all modules. This module has frequently used packages like java.util. That’s what the mandated is about. You get java.base whether you asked for it or not.It is automatically available to all other modules.
=================

java -p mods -d zoo.animal.care


zoo.animal.care file:///absolutePath/mods/zoo.animal.care.jar
requires zoo.animal.feeding transitive
requires java.base mandated
qualified exports zoo.animal.care.medical to zoo.staff
contains zoo.animal.care.details
The first line of the output is the absolute path of the module file. The two requires lines should look familiar as well. The first is in the module-info, and the other is added to all modules. Next comes something new. The qualified exports is the full name of exporting to a specific module.

Finally, the contains means that there is a package in the module that is not exported at all. This is true. Our module has two packages, and one is available only to code inside the module.
==============================
In addition to describing modules, you can use the java command to list the modules that are available. The simplest form lists the modules that are part of the JDK:

java --list-modules

When we ran it, the output went on for 70 lines and looked like this:

java.base@11.0.2
java.compiler@11.0.2
java.datatransfer@11.0.2
======================================

java -p mods --list-modules
How many lines do you expect to be in the output this time? There are 74 lines now: the 70 built-in modules plus the four in our zoo system. The custom lines look like this:

zoo.animal.care file:///absolutePath/mods/zoo.animal.care.jar
zoo.animal.feeding file:///absolutePath/mods/zoo.animal.feeding.jar
zoo.animal.talks file:///absolutePath/mods/zoo.animal.talks.jar
zoo.staff file:///absolutePath/mods/zoo.staff.jar
================================

java --show-module-resolution
   -p feeding
   -m zoo.animal.feeding/zoo.animal.feeding.Task

Luckily you don’t need to understand this output. That said, having seen it will make it easier to remember. Here’s a snippet of the output:


root zoo.animal.feeding file:///absolutePath/feeding/
java.base binds java.desktop jrt:/java.desktop
java.base binds jdk.jartool jrt:/jdk.jartool
...
jdk.security.auth requires java.naming jrt:/java.naming
jdk.security.auth requires java.security.jgss jrt:/java.security.jgss
...
All fed!
It starts out by listing the root module. That’s the one we are running: zoo.animal .feeding. Then it lists many lines of packages included by the mandatory java.base module. After a while, it lists modules that have dependencies. Finally, it outputs the result of the program All fed!. The total output of this command is 66 lines.
=====================

jar -f mods/zoo.animal.feeding.jar -d
jar --file mods/zoo.animal.feeding.jar --describe-module
The output is slightly different from when we used the java command to describe the module. With jar, it outputs the following:

zoo.animal.feeding jar:file:///absolutePath/mods/zoo.animal.feeding.jar /!module-info.class
exports zoo.animal.feeding
requires java.base mandated

====================

The jdeps command gives you information about dependencies within a module. Unlike describing a module, it looks at the code in addition to the module-info file. This tells you what dependencies are actually used rather than simply declared.

jdeps -s mods/zoo.animal.feeding.jar
jdeps -summary mods/zoo.animal.feeding.jar

Notice that there is one dash (-) before -summary rather than two. Regardless, the output tells you that there is only one package and it depends on the built-in java.base module.
zoo.animal.feeding -> java.base

Alternatively, you can call jdeps without the summary option and get the long form:


jdeps mods/zoo.animal.feeding.jar
[file:///absolutePath/mods/zoo.animal.feeding.jar]
   requires mandated java.base (@11.0.2)
zoo.animal.feeding -> java.base
   zoo.animal.feeding         -> java.io
      java.base
   zoo.animal.feeding         -> java.lang
      java.base
==============================
jdeps -s
   --module-path mods
   mods/zoo.animal.care.jar
 
jdeps -summary
   --module-path mods
   mods/zoo.animal.care.jar
There is not a short form of --module-path in the jdeps command. The output is only two lines:


zoo.animal.care -> java.base
zoo.animal.care -> zoo.animal.feeding
=====================

jdeps --module-path mods
   mods/zoo.animal.care.jar
This time we get lots of output:
zoo.animal.care
   [file:///absolutePath/mods/zoo.animal.care.jar]
      requires mandated java.base (@11.0.2)
      requires transitive zoo.animal.feeding
   zoo.animal.care -> java.base
   zoo.animal.care -> zoo.animal.feeding
      zoo.animal.care.details     -> java.lang                                        
         java.base
      zoo.animal.care.details     -> zoo.animal.feeding                                
         zoo.animal.feeding
      zoo.animal.care.medical     -> java.lang                                        
         java.base

=============================
The final command you need to know for the exam is jmod. You might think a JMOD file is a Java module file. Not quite. Oracle recommends using JAR files for most modules. JMOD files are recommended only when you have native libraries or something that can’t go inside a JAR file. This is unlikely to affect you in the real world.

The most important thing to remember is that jmod is only for working with the JMOD files. Conveniently, you don’t have to memorize the syntax for jmod. Table 11.4 lists the common modes.
========================
Table 11.4: Modes using jmod
Operation

Description

create

Creates a JMOD file.

extract

Extracts all files from the JMOD. Works like unzipping.

describe

Prints the module details such as requires.

list

Lists all files in the JMOD file.

hash

Shows a long string that goes with the file
======================

Description                                                                                                Syntax
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Compile nonmodular code                                                                   javac -cp classpath -d directory classesToCompile

                                                                                          javac --class-path classpath -d directory classesToCompile

                                                                                          javac -classpath classpath -d directory classesToCompile
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Run nonmodular code                                                                      java -cp classpath package.className

                                                                                         java -classpath classpath package.className

                                                                                         java --class-path classpath package.className
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Compile a module                                                                         javac -p moduleFolderName -d directory classesToCompileIncludingModuleInfo

                                                                                         javac --module-path moduleFolderName -d directory classesToCompileIncludingModuleInfo
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Run a module                                                                             java -p moduleFolderName -m moduleName/package.className

                                                                                         java --module-path moduleFolderName --module moduleName/package.className
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Describe a module                                                                        java -p moduleFolderName -d moduleName

                                                                                         java --module-path moduleFolderName --describe-module moduleName

                                                                                         jar --file jarName --describe-module

                                                                                         jar -f jarName -d
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
List available modules                                                                   java --module-path moduleFolderName --list-modules

                                                                                         java -p moduleFolderName --list-modules

                                                                                         java --list-modules
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
View dependencies                                                                        jdeps -summary --module-path moduleFolderName jarName

                                                                                         jdeps -s --module-path moduleFolderName jarName
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Show module resolution                                                                   java --show-module-resolution -p moduleFolderName -m moduleName

                                                                                         java --show-module-resolution --module-path moduleFolderName --module moduleName
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
=========================
Options you need to know for the exam: javac
==================================================
-cp <classpath>
-classpath <classpath>
--class-path <classpath>                  Location of JARs in a nonmodular program
-----------------------------------------------------------------
-d <dir>                                  Directory to place generated class files
----------------------------------------------------------------------------
-p <path>
--module-path <path>                       Location of JARs in a modular program
------------------------------------------------------------------------------------------
==============================
Options you need to know for the exam: java
=============================================================================================
Option                                                        Description

-p <path>
--module-path <path>                                    Location of JARs in a modular program
------------------------------------------------------------------------------
-m <name>
--module <name>                                         Module name to run
------------------------------------------------------------------
-d
--describe-module                                      Describes the details of a module
--------------------------------------------------------------------------------
--list-modules                                        Lists observable modules without running a program
------------------------------------------------------------------------------
--show-module-resolution                             Shows modules when running program
-----------------------------------------------------------------------------------------------
===============================================
Table 11.8: Options you need to know for the exam: jar
==========================================================
Option                     Description

-c
--create                Create a new JAR file
---------------------------------------
-v
--verbose              Prints details when working with JAR files
-------------------------------------
-f
--file                 JAR filename
-------------------------------------------------
-C                  Directory containing files to be used to create the JAR
-----------------------------------------------------------
-d
--describe-module      Describes the details of a module
------------------------------------------------------------
==============================
Table 11.9: Options you need to know for the exam: jdeps
===============================================
Option                Description
--module-path <path>    Location of JARs in a modular program
-----------------------------
-s
-summary       Summarizes output
---------------------------------------
The Java Platform Module System organizes code at a higher level than packages. 
==========================
!! NB !!
==========================
The Java Platform Module System organizes code at a higher level than packages. Each module contains one or more packages and a module-info file. Advantages of the JPMS include better access control, clearer dependency management, custom runtime images, improved performance, and unique package enforcement.

The process of compiling and running modules uses the --module-path, also known as -p. Running a module uses the --module option, also known as -m. The class to run is specified in the format moduleName/className.

The module-info file supports a number of keywords. The exports keyword specifies that a package should be accessible outside the module. It can optionally restrict that export to a specific package. The requires keyword is used when a module depends on code in another module. Additionally, requires transitive can be used when all modules that require one module should always require another. The provides and uses keywords are used when sharing and consuming an API. Finally, the opens keyword is used for allowing access via reflection.

Both the java and jar commands can be used to describe the contents of a module. The java command can additionally list available modules and show module resolution. The jdeps command prints information about packages used in addition to module-level information. Finally, the jmod command is used when dealing with files that don’t meet the requirements for a JAR.
==========================================
a.A central repository of all modules

b.Encapsulating packages

c.Encapsulating objects

d.No defined types

e.Platform independence

Option B is correct since modules allow you to specify which packages can be called by external code.(ENCAPSULATION) Options C and E are incorrect because they are provided by Java without the module system. Option A is incorrect because there is not a central repository of modules. Option D is incorrect because Java defines types.
=============================================
!! NB !!
 opens is for reflection and uses declares an API that consumes a service:

The opens keyword allows the use of reflection.
The uses keyword declares an API is called.
The file can be empty (zero bytes).
============================================================
B, C. Packages inside a module are not exported by default, making option B correct and option A incorrect. Exporting is necessary for other code to use the packages; it is not necessary to call the main() method at the command line, making option C correct and option D incorrect. The module-info.java file has the correct name and compiles, making options E and F incorrect.
========================
Which commands take a --module-path parameter? (Choose all that apply.)

javac

java

jar

jdeps

jmod

None of the above

Answer:
A, B, D. Options A and B are correct because the -p (--module-path) option can be passed when compiling or running a program. Option D is also correct because jdeps can use the --module-path option when listing dependency information
========================
--show-module-resolution option? -  The java command uses this option to print information when the program loads. You might think jar does the same thing since it runs a program too. Alas, this parameter does not exist on jar.
====================================
When running java with the -d option, all the required modules are listed. Additionally, the java.base module is listed since it is included automatically. The line ends with mandated, making option A correct. The java.lang is a trick since that is a package that is imported by default in a class rather than a module.
=========================================
the java command has an --add-exports option that allows exporting a package at runtime. However, it is not encouraged to use it.
================================
jdeps -s flea.jar

jdeps -summary flea.jar
========================
Module names look a lot like package names. Each segment is separated by a period (.) and uses characters valid in Java identifiers. identifiers are not allowed to begin with numbers,  Dashes (-) are not allowed either
com.book
com.book$
======================================
 Option A is incorrect because describe-module has the d equivalent. Option C is incorrect because module has the m equivalent. Option D is incorrect because module-path has the p equivalent. Option F is incorrect because summary has the s equivalent. Options B and E are the correct answers because they do not have equivalents.
describe-module
which doesnt have abbreviation?
list-modules

module

module-path

show-module-resolution

summary
============================
CHAPTER 12: JAVA FUNDAMENTALS
=======================
marking a variable final means the value cannot be changed after it is assigned. 
private void printZooInfo(boolean isWeekend) {
   final int giraffe = 5;
   final long lemur;
   if(isWeekend) lemur = 5;
   else lemur = 10;
   System.out.println(giraffe+" "+lemur);
}
As shown with the lemur variable, we don't need to assign a value when a final variable is declared. The rule is only that it must be assigned a value before it can be used.
=================================
The compiler does not allow the use of local variables that may not have been assigned a value, whether they are marked final or not.
===================
Just because a variable reference is marked final does not mean the object associated with it cannot be modified. Consider the following code snippet:

final StringBuilder cobra = new StringBuilder();
cobra.append("Hssssss");
cobra.append("Hssssss!!!");
In the cobra example, the object reference is constant, but that doesn't mean the data in the class is constant.
============================
Instance and static class variables can also be marked final. If an instance variable is marked final, then it must be assigned a value when it is declared or when the object is instantiated. Like a local final variable, it cannot be assigned a value more than once, though
-----------------------
public class PolarBear {
   final int age = 10;
   final int fishEaten;
   final String name;

   { fishEaten = 10; }

   public PolarBear() {
      name = "Robert";
   }
   public PolarBear(int height) {
      this();
   }
}
===========================
Methods marked final cannot be overridden by a subclass. Marking a method or class final means it cannot be overridden or extended, respectively.
Enum values are considered constants and are commonly written using snake case, often stylized as snake_case. This style uses an underscore ( _) to separate words with constant values commonly written in all uppercase. For example, an enum declaring a list of ice cream flavors might include values like VANILLA, ROCKY_ROAD, MINT_CHOCOLATE_CHIP, and so on.
Behind the scenes, an enum is a type of class that mainly contains static members. It also includes some helper methods like name().
Season s = Season.SUMMER;
System.out.println(Season.SUMMER); // SUMMER
System.out.println(s == Season.SUMMER); // true
--------------------------------
An enum provides a values() method to get an array of all of the values. 
for(Season season: Season.values()) {
   System.out.println(season.name() + " " + season.ordinal());
}
The output shows that each enum value has a corresponding int value, and the values are listed in the order in which they are declared.
--------------------------------
You can't compare an int and enum value directly anyway since an enum is a type, like a Java class, and not a primitive int.
if ( Season.SUMMER == 2) {} // DOES NOT COMPILE
-----------------------
Season s = Season.valueOf("SUMMER"); // SUMMER
Season t = Season.valueOf("summer"); // Throws an exception at runtime
---------------------------------
Season summer = Season.SUMMER;
switch (summer) {
   case WINTER:
      System.out.println("Get out the sled!");
      break;
   case SUMMER:
      System.out.println("Time for the pool!");
      break;
   default:
      System.out.println("Is it summer yet?");
}
---------------------
switch (summer) {
   case Season.FALL:  // DOES NOT COMPILE
      System.out.println("Rake some leaves!");
      break;
   case 0:            // DOES NOT COMPILE
      System.out.println("Get out the sled!");
      break;
}
------------------
1: public enum Season {
2:    WINTER("Low"), SPRING("Medium"), SUMMER("High"), FALL("Medium");
3:    private final String expectedVisitors;
4:    private Season(String expectedVisitors) {
5:       this.expectedVisitors = expectedVisitors;
6:    }
7:    public void printExpectedVisitors() {
8:       System.out.println(expectedVisitors);
9:    } }

public static void main(String[] args) {
        System.out.println("winter: " + Season.WINTER);
        System.out.println("vals: " + Arrays.toString(Season.values()));
        Season.SUMMER.printExpectedVisitors();
    }
    output:
    winter: WINTER
    vals: [WINTER, SPRING, SUMMER, FALL]
    High
    ----------------------
    for(Season season: Season.values()) {
       System.out.println(season.name() + " " + season.ordinal());
    }
    The output shows that each enum value has a corresponding int value, and the values are listed in the order in which they are declared.
    WINTER 0
    SPRING 1
    SUMMER 2
    FALL 3
    You can't compare an int and enum value directly anyway since an enum is a type, like a Java class, and not a primitive int.
     if ( Season.SUMMER == 2) {} // DOES NOT COMPILE

Season s = Season.valueOf("SUMMER"); // SUMMER
Season t = Season.valueOf("summer"); // Throws an exception at runtime
-------------------------
Season summer = Season.SUMMER;
switch (summer) {
   case WINTER:
      System.out.println("Get out the sled!");
      break;
   case SUMMER:
      System.out.println("Time for the pool!");
      break;
   default:
      System.out.println("Is it summer yet?");
}

switch (summer) {
   case Season.FALL:  // DOES NOT COMPILE
      System.out.println("Rake some leaves!");
      break;
   case 0:            // DOES NOT COMPILE
      System.out.println("Get out the sled!");
      break;
}
===========================================
!! NB !!
All enum constructors are implicitly private, with the modifier being optional. This is reasonable since you can't extend an enum and the constructors can be called only within the enum itself. An enum constructor will not compile if it contains a public or protected modifier.
=====================================================

How do we call an enum method? It's easy: Season.SUMMER.printExpectedVisitors();
------------------------
public enum OnlyOne {
   ONCE(true);
   private OnlyOne(boolean b) {
      System.out.print("constructing,");
   }
}

public class PrintTheOne {
   public static void main(String[] args) {
      System.out.print("begin,");
      OnlyOne firstCall = OnlyOne.ONCE;  // prints constructing,
      OnlyOne secondCall = OnlyOne.ONCE; // doesn't print anything
      System.out.print("end");
   }
}
----------------------------
public enum Season {
   WINTER {
      public String getHours() { return "10am-3pm"; }
   },
   SPRING {
      public String getHours() { return "9am-5pm"; }
   },
   SUMMER {
      public String getHours() { return "9am-7pm"; }
   },
   FALL {
      public String getHours() { return "9am-5pm"; }
   };
   public abstract String getHours();
}

If we don't want each and every enum value to have a method, we can create a default implementation and override it only for the special cases.


public enum Season {
   WINTER {
      public String getHours() { return "10am-3pm"; }
   },
   SUMMER {
      public String getHours() { return "9am-7pm"; }
   },
   SPRING, FALL;
   public String getHours() { return "9am-5pm"; }
}
===================================
NESTED CLASSES
===================================================
A nested class is a class that is defined within another class. A nested class can come in one of four flavors.
Inner class: A non‐ static type defined at the member level of a class
Static nested class: A static type defined at the member level of a class
Local class: A class defined within a method body
Anonymous class: A special case of a local class that does not have a name
---------------
 interfaces and enums can be declared as both inner classes and static nested classes, but not as local or anonymous classes.
------------------------------------------------
============ NB =====================
INNER NON STATIC CLASS: Can be declared public, protected, package‐private (default), or private
Can extend any class and implement interfaces
Can be marked abstract or final
nb !!!! Cannot declare static fields or methods, except for static final fields
Can access members of the outer class including private members
=========================
20:    public static void main(String[] args) {
21:       Outer outer = new Outer();
22:       Inner inner = outer.new Inner(); // create the inner class
23:       inner.go();
24:    }
===================================
1:  public class A {
2:     private int x = 10;
3:     class B {
4:        private int x = 20;
5:        class C {
6:           private int x = 30;
7:           public void allTheX() {
8:              System.out.println(x);        // 30
9:              System.out.println(this.x);   // 30
10:             System.out.println(B.this.x); // 20
11:             System.out.println(A.this.x); // 10
12:    } } }
13:    public static void main(String[] args) {
14:       A a = new A();
15:       A.B b = a.new B();
16:       A.B.C c = b.new C();
17:       c.allTheX();
18: }}
===================================
    public class Fox {
       private class Den {}
       public void goHome() {
          new Den();
       }
       public static void visitFriend() {
          new Den();  // DOES NOT COMPILE; need to mention new Fox
       }
    }

    public class Squirrel {
       public void visitFox() {
          new Den();  // DOES NOT COMPILE: private and would've needed to add new Fox()
       }
    }
===============================
A static nested class is a static type defined at the member level. Unlike an inner class, a static nested class can be instantiated without an instance of the enclosing class.The trade‐off, though, is it can't access instance variables or methods in the outer class directly. It can be done but requires an explicit reference to an outer class variable. The enclosing class can refer to the fields and methods of the static nested class.
1: public class Enclosing {
2:    static class Nested {
3:       private int price = 6;
4:    }
5:    public static void main(String[] args) {
6:       Nested nested = new Nested();
7:       System.out.println(nested.price);
8: } }
Line 6 instantiates the nested class. Since the class is static, you do not need an instance of Enclosing to use it. You are allowed to access private instance variables, which is shown on line 7.
--------------------------------
 // Toucan.java
    package bird;
    public class Toucan {
       public static class Beak {}
    }

    // BirdWatcher.java
    package watcher;
    import bird.Toucan.Beak; // regular import ok
    import static bird.Toucan.Beak; // this works too
    public class BirdWatcher {
       Beak beak;
    }
-------------------------------
A local class is a nested class defined within a method. Like local variables, a local class declaration does not exist until the method is invoked, and it goes out of scope when the method returns. 
Local classes have the following properties:
They do not have an access modifier.
They cannot be declared static and cannot declare static fields or methods, except for static final fields.
They have access to all fields and methods of the enclosing class (when defined in an instance method).
They can access local variables if the variables are final or effectively final.
==================================================
Anonymous classes are required to extend an existing class or implement an existing interface. They are useful when you have a short implementation that will not be used anywhere else. Here's an example:
1:  public class ZooGiftShop {
2:     abstract class SaleTodayOnly {
3:        abstract int dollarsOff();
4:     }
5:     public int admission(int basePrice) {
6:        SaleTodayOnly sale = new SaleTodayOnly() {
7:           int dollarsOff() { return 3; }
8:        };  // !!! NB !!!	 Don't forget the semicolon!
9:        return basePrice - sale.dollarsOff();
10: } }
!!  Local variable declarations are required to end with semicolons, just like other Java statements—even if they are long and happen to contain an anonymous class.
==========================================
1:  public class ZooGiftShop {
2:     interface SaleTodayOnly {
3:        int dollarsOff();
4:     }
5:     public int admission(int basePrice) {
6:        SaleTodayOnly sale = new SaleTodayOnly() {
7:           public int dollarsOff() { return 3; }
8:        };
9:        return basePrice - sale.dollarsOff();
10: } }
The most interesting thing here is how little has changed. Lines 2 through 4 declare an interface instead of an abstract class. Line 7 is public instead of using default access since interfaces require public methods.
--------------------------------
But what if we want to implement both an interface and extend a class? You can't with an anonymous class, unless the class to extend is java.lang.Object.  Remember that an anonymous class is just an unnamed local class. You can write a local class and give it a name if you have this problem. Then you can extend a class and implement as many interfaces as you like.
-----------------
Permitted Modifiers	Inner class	Static nested class	Local class	Anonymous class
Access modifiers	All	           All	                    None	None
Abstract	         Yes	            Yes	                     Yes	No
Final	                 Yes	             Yes	             Yes	No
=================================
A default method is assumed to be public.
A default method cannot be marked abstract, final, or static.
If a class inherits two or more default methods with the same method signature, then the class must override the method.
=======================================================
public interface Walk {
   public default int getSpeed() { return 5; }
}

public interface Run {
   public default int getSpeed() { return 10; }
}

public class Cat implements Walk, Run {  // DOES NOT COMPILE
   public static void main(String[] args) {
      System.out.println(new Cat().getSpeed());
   }
}
BUT:
public class Cat implements Walk, Run {
   public int getSpeed() { return 1; }
 
   public static void main(String[] args) {
      System.out.println(new Cat().getSpeed());
   }
}
======================================================
Calling a Hidden default Method
public class Cat implements Walk, Run {
   public int getSpeed() { return 1; }

   public int getWalkSpeed() {
      return ___________; // TODO: Call Walk's version of getSpeed()
   }

   public static void main(String[] args) {
      System.out.println(new Cat().getWalkSpeed());
   }
}
This is an area where a default method exhibits properties of both a static and instance method. Ready for the answer? Well, first off, you definitely can't call Walk.getSpeed(). A default method is treated as part of the instance since they can be overridden, so they cannot be called like a static method.
public class Cat implements Walk, Run {
   public int getSpeed() {
      return 1;
   }

   public int getWalkSpeed() {
      return Walk.super.getSpeed();    !!! NB !!!
   }

   public static void main(String[] args) {
      System.out.println(new Cat().getWalkSpeed());
   }
}
================================
Static Interface Method Definition Rules
A static method must be marked with the static keyword and include a method body.

A static method without an access modifier is assumed to be public.

A static method cannot be marked abstract or final.

A static method is not inherited and cannot be accessed in a class implementing the interface without a reference to the interface name.
===============================
!!! NB !!! interfaces may now include private interface methods.A private interface method may be called only by default and private (non‐ static) methods within the interface definition.
=============================
public interface Swim {
   private static void breathe(String type) {
      System.out.println("Inhale");
      System.out.println("Performing stroke: " + type);
      System.out.println("Exhale");
   }
   static void butterfly()        { breathe("butterfly");  }
   public static void freestyle() { breathe("freestyle");  }
   default void backstroke()      { breathe("backstroke"); }
   private void breaststroke()    { breathe("breaststroke"); }
}
=====================
A private static interface method may be called only by other methods within the interface definition.
!!! Both private and private static methods can be called from default and private methods.. On the other hand, a private method cannot be called from a private static method.
. A key distinction, though, is that interfaces do not implement constructors and are not part of the class hierarchy. While a class can implement multiple interfaces, it can only directly extend a single class.
=============================
Declaring a Functional Interface with Object Methods
all classes inherit certain methods from Object. For the exam, you should be familiar with the following Object method declarations:
String toString()
boolean equals(Object)
int hashCode()
--------------------------------------------------------
 If a functional interface includes an abstract method with the same signature as a public method found in Object, then those methods do not count toward the single abstract method test. The motivation behind this rule is that any class that implements the interface will inherit from Object, as all classes do, and therefore always implement these methods.
Note	
Since Java assumes all classes extend from Object, you also cannot declare an interface method that is incompatible with Object. For example, declaring an abstract method int toString() in an interface would not compile since Object's version of the method returns a String.

Let's take a look at an example. Is the Soar class a functional interface?


public interface Soar {
   abstract String toString();
}
It is not. Since toString() is a public method implemented in Object, it does not count toward the single abstract method test.

On the other hand, the following implementation of Dive is a functional interface:


public interface Dive {
   String toString();
   public boolean equals(Object o);
   public abstract int hashCode();
   public void dive();
}
=============================
public interface Hibernate {
   String toString();
   public boolean equals(Hibernate o);
   public abstract int hashCode();
   public void rest();
}
Despite looking a lot like our Dive interface, the Hibernate interface uses equals(Hibernate) instead of equals(Object). Because this does not match the method signature of the equals(Object) method defined in the Object class, this interface is counted as containing two abstract methods: equals(Hibernate) and rest().
===========================
hashCode(): Any time you override equals(Object), you must override hashCode() to be consistent. This means that for any two objects, if a.equals(b) is true, then a.hashCode()==b.hashCode() must also be true. If they are not consistent, then this could lead to invalid data and side effects in hash‐based collections such as HashMap and HashSet.===================
=========================================================
any functional interface can be implemented as a lambda expression.
public interface Predicate<T> {
   boolean test(T t);
}
=================================
public class Animal {
   private String species;
   private boolean canHop;
   private boolean canSwim;
   public Animal(String speciesName, boolean hopper, boolean swimmer) {
      species = speciesName;
      canHop = hopper;
      canSwim = swimmer;
   }
   public boolean canHop()  { return canHop; }
   public boolean canSwim() { return canSwim; }
   public String toString() { return species; }
}
===================
Lambda expressions rely on the notion of deferred execution. Deferred execution means that code is specified now but runs later. In this case, later is when the print() method calls it. Even though the execution is deferred, the compiler will still validate that the code syntax is correct.
---
all correct:

() -> new Duck()
d -> {return d.quack();}
(Duck d) -> d.quack()
(Animal a, Duck d) -> d.quack()
-------------------
 we needed a lambda that returns a boolean value. Do you see what's wrong with each of these?


3: a, b -> a.startsWith("test")         // DOES NOT COMPILE
4: Duck d -> d.canQuack();              // DOES NOT COMPILE
5: a -> { a.startsWith("test"); }       // DOES NOT COMPILE
6: a -> { return a.startsWith("test") } // DOES NOT COMPILE
7: (Swan s, t) -> s.compareTo(t) != 0   // DOES NOT COMPILE
Lines 3 and 4 require parentheses around each parameter list. Remember that the parentheses are optional only when there is one parameter and it doesn't have a type declared. Line 5 is missing the return keyword, which is required since we said the lambda must return a boolean. Line 6 is missing the semicolon inside of the braces, {}. Finally, line 7 is missing the parameter type for t. If the parameter type is specified for one of the parameters, then it must be specified for all of them.
------------------------

interchangeable:
Predicate<String> p = x -> true;
Predicate<String> p = (var x) -> true;
Predicate<String> p = (String x) -> true;
---------------------------------------

public void whatAmI() {
   test((var x) -> x>2, 123);
}

public void test(Predicate<Integer> c, int num) {
   c.test(num);
}
===================================
!!! Restrictions on Using var in the Parameter List
While you can use var inside a lambda parameter list, there is a rule you need to be aware of. If var is used for one of the types in the parameter list, then it must be used for all parameters in the list. 
====================
11: public void variables(int a) {
12:    int b = 1;
13:    Predicate<Integer> p1 = a -> {
14:       int b = 0;
15:       int c = 0;
16:       return b == c;}
17: }
3 synthax errors: l.13: cant redeclare a, l.14: cant redeclare b; l.16: missing ; at the end of p1
=======================================
Lambda bodies are allowed to use static variables, instance variables, and local variables if they are final or effectively final. 
4:  public class Crow {
5:     private String color;
6:     public void caw(String name) {
7:        String volume = "loudly";
8:        color = "allowed";
9:        name = "not allowed"; // doesnt compile: not effectively final
10:       volume = "not allowed"; // same
11:       Predicate<String> p =
12:          s -> (name+volume+color).length()==9; // DOES NOT COMPILE
13:    }
14: }
In this example, the values of name and volume are assigned new values on lines 9 and 10. For this reason, the lambda expression declared on lines 11 and 12 does not compile since it references local variables that are not final or effectively final. If lines 9 and 10 were removed, then the class would compile.
================================
Instance and static variables can be marked final.

 When an enum contains only a list of values, the semicolon (;) after the list is optional. When an enum contains any other members, such as a constructor or variable, then it is required:
  public class FlavorsEnum {
           enum Flavors {
              VANILLA, CHOCOLATE, STRAWBERRY // in this case u need ;
              static final Flavors DEFAULT = STRAWBERRY;
           }
           public static void main(String[] args) {
              for(final var e : Flavors.values())
                 System.out.print(e.ordinal()+" ");
           }
        }
If the missing semicolon was added, then the program would print 0 1 2 at runtime.

The purpose of this line is to provide a default flavor for the Flavors enum. If at any point in the program you need a default or fallback value, you can reference Flavors.DEFAULT, which will always return the STRAWBERRY flavor.
==============================

  1:  public class Movie {
        2:     private int butter = 5;
        3:     private Movie() {}
        4:     protected class Popcorn {
        5:        private Popcorn() {}
        6:        public static int butter = 10; // !!! Inner classes are only allowed to contain static variables that are marked final. 
        7:        public void startMovie() {
        8:           System.out.println(butter);
        9:        }
        10:    }
        11:    public static void main(String[] args) {
        12:       var movie = new Movie();
        13:       Movie.Popcorn in = new Movie().new Popcorn();
        14:       in.startMovie();
        15:    } }
If the final modifier was added on line 6, then the code would print 10 at runtime. Note that private constructors can be used by any methods within the same class.
==============================

A default interface method can be declared private.

A default interface method can be declared public.

A default interface method can be declared static.

A private interface method can be declared abstract.

A private interface method can be declared protected.

A private interface method can be declared static.

Answer:
B, F. A default interface method is always public, whether you include the identifier or not, making option B correct and option A incorrect. Interfaces cannot contain default static methods, making option C incorrect. Option D is incorrect, as private interface methods are not inherited and cannot be marked abstract. Option E is incorrect, as a method can't be marked both protected and private. Finally, interfaces can include both private and private static methods, making option F correct.
=============================================

(Wolf w, var c) ‐> 39

(final Camel c) ‐> {}

(a,b,c) ‐> {int b = 3; return 2;}

(x,y) ‐> new RuntimeException()

(var y) ‐> return 0;

() ‐> {float r}

(Cat a, b) ‐> {}

Answer:
B, D. Option B is a valid functional interface, one that could be assigned to a Consumer<Camel> reference. Notice that the final modifier is permitted on variables in the parameter list. Option D is correct, as the exception is being returned as an object and not thrown. This would be compatible with a BiFunction that included RuntimeException as its return type.
Option A is incorrect because it mixes var and non-var parameters. If one argument uses var, then they all must use var. Option C is invalid because the variable b is used twice. Option E is incorrect, as a return statement is permitted only inside braces ({}). Option F is incorrect because the variable declaration requires a semicolon (;) after it. Finally, option G is incorrect. If the type is specified for one argument, then it must be specified for each and every argument.
==============
What are some advantages of using private interface methods? (Choose all that apply.)
Reduce code duplication
Encapsulate interface implementation
==========================

    public class IceCream {
           enum Flavors {
              CHOCOLATE, STRAWBERRY, VANILLA
           }

           public static void main(String[] args) {
              Flavors STRAWBERRY = null;
              switch (STRAWBERRY) {
                 case Flavors.VANILLA: System.out.print("v");
                 case Flavors.CHOCOLATE: System.out.print("c");
                 case Flavors.STRAWBERRY: System.out.print("s");
                 break;
                 default: System.out.println("missing flavor"); }
           }
        }
Flavors STRAWBERRY = null;
declares a local variable named STRAWBERRY of type Flavors and initializes it with null. This is allowed because, in Java, enum values are just objects, and object references can be null.
. If these three lines were corrected, then the code would compile and produce a NullPointerException at runtime.
=========================================
!!! A functional interface can contain any number of nonabstract methods including default, private, static, and private static
===============================================
 public class Ghost {
           public static void boo() {
              System.out.println("Not scared");
           }
           protected final class Spirit {
              public void boo() {
                 System.out.println("Booo!!!");
              }
           }
           public static void main(String... haunt) {
              var g = new Ghost().new Spirit() {};
              ___________________________;
           }
        }
The main() method uses an anonymous inner class that inherits from Spirit, which is not allowed. 
 Anonymous inner classes are unnamed subclasses of a class or an implementation of an interface. 
An anonymous inner class is a subclass of the class (or implementation of the interface) you're instantiating, even if you don’t explicitly write extends. By adding {}, you’re essentially saying, "I’m creating a subclass of Spirit on the fly and optionally overriding some methods or adding functionality inside the {}."
The reason the extends keyword isn’t required is that anonymous inner classes automatically inherit (or "extend") the behavior of the class or interface they are based on. Java does this behind the scenes for anonymous inner classes. So even without the keyword, it's understood by the compiler that the anonymous class extends the original class (Spirit in this case).
===============================================================
    1:  public interface CanWalk {
        2:     default void walk() { System.out.print("Walking"); }
        3:     private void testWalk() {}
        4:  }
        5:  public interface CanRun {
        6:     abstract public void run();
        7:     private void testWalk() {}
        8:     default void walk() { System.out.print("Running"); }
        9:  }
        10: public interface CanSprint extends CanWalk, CanRun { // not compile here cause walk is not overridden but overloaded !!!
        11:    void sprint();
        12:    default void walk(int speed) {
        13:       System.out.print("Sprinting");
        14:    }
        15:    private void testWalk() {}
        16: }
 CanWalk and CanRun both implement a default walk() method. The definition of CanSprint extends these two interfaces and therefore won't compile unless the interface overrides both inherited methods. The version of walk() on line 12 is an overload, not an override, since it takes an int value. Since the interface doesn't override the methods, the compiler can't decide which default method to use, leading to a compiler error and making option D the correct answer.
===================================
!!! lambda implements func interface method as anonym method: Lambda expressions automatically implement the functional interface method.
You pass them directly where an interface is expected.
!!!! 
@FunctionalInterface
interface MyFunction {
   int apply(int a, int b);
}

public class Main {
   public static void main(String[] args) {
      execute((a, b) -> a * b);
   }

   static void execute(MyFunction f) {
      System.out.println(f.apply(5, 3)); // Executes lambda
   }
}
===============================
   1: public interface Herbivore {
        2:    int amount = 10;
        3:    static boolean gather = true;
        4:    static void eatGrass() {}
        5:    int findMore() { return 2; }
        6:    default float rest() { return 2; }
        7:    protected int chew() { return 13; }
        8:    private static void eatLeaves() {}
        9: }
dont compile lies 5 and 7:
E, G. For this question, it helps to remember which implicit modifiers the compiler will insert and which it will not. Lines 2 and 3 compile with interface variables assumed to be public, static, and final. Line 4 also compiles, as static methods are assumed to be public if not otherwise marked. Line 5 does not compile. Non-static methods within an interface must be explicitly marked private or default. Line 6 compiles, with the public modifier being added by the compiler. Line 7 does not compile, as interfaces do not have protected members. Finally, line 8 compiles, with no modifiers being added by the compiler.
=========================================
Which of the following can be inserted in the rest() method? (Choose all that apply.)

        public class Lion {
           class Cub {}
           static class Den {}
           static void rest() {
           ___________________;
           } }
Cub a = Lion.new Cub()

Lion.Cub b = new Lion().Cub()

Lion.Cub c = new Lion().new Cub()

var d = new Den()

var e = Lion.new Cub()

Lion.Den f = Lion.new Den()

Lion.Den g = new Lion.Den()

var h = new Cub()

Answer:
correct: Lion.Cub c = new Lion().new Cub() // Lion.Cub is the type!!
var d = new Den()
Lion.Den f = Lion.new Den()

C, D, G. Option C is the correct way to create an instance of an inner class Cub using an instance of the outer class Lion. The syntax looks weird, but it creates an object of the outer class and then an object of the inner class from it. Options A, B, and E use incorrect syntax for creating an instance of
=============================================================
Given the following program, what can be inserted into the blank line that would allow it to print Swim! at runtime?

        interface Swim {
           default void perform() { System.out.print("Swim!"); }
        }
        interface Dance {
           default void perform() { System.out.print("Dance!"); }
        }
        public class Penguin implements Swim, Dance {
           public void perform() { System.out.print("Smile!"); }
           private void doShow() {
              ____________________
           }
           public static void main(String[] eggs) {
              new Penguin().doShow();
           }
        }
super.perform();

Swim.perform();

super.Swim.perform();

Swim.super.perform();

The code does not compile regardless of what is inserted into the blank.

The code compiles, but due to polymorphism, it is not possible to produce the requested output without creating a new object.

Answer:
D. First off, if a class or interface inherits two interfaces containing default methods with the same signature, then it must override the method with its own implementation. The Penguin class does this correctly, so option E is incorrect. The way to access an inherited default method is by using the syntax Swim.super.perform(), making option D correct. We agree the syntax is bizarre, but you need to learn it. Options A, B, and C are incorrect and result in compiler errors.
=============================
The value of an effectively final variable is not modified after it is set.

A lambda expression can reference effectively final variables.

A lambda expression can reference final variables.

If the final modifier is added, the code still compiles.
=========================================

wrong:::
Instance variables can be effectively final. // can not

Static variables can be effectively final.
============================

Which lines of the following interface do not compile? (Choose all that apply.)

        1: public interface BigCat {
        2:    abstract String getName();
        3:    static int hunt() { getName(); return 5; }
        4:    default void climb() { rest(); }
        5:    private void roar() { getName();  climb(); hunt(); }
        6:    private static boolean sneak() { roar(); return true; }
        7:    private int rest() { return 2; };
        8: }
Line 2

Line 3

Line 4

Line 5

Line 6

Line 7

None of the above

Answer:
B, E. Like classes, interfaces allow instance methods to access static members, but not vice versa. Non-static private, abstract, and default methods are considered instance methods in interfaces. Line 3 does not compile because the static method hunt() cannot access an abstract instance method getName(). Line 6 does not compile because the private static method sneak() cannot access the private instance method roar(). The rest of the lines compile without issue.
============================================

What are some advantages of using default interface methods? (Choose all that apply.)

Backward compatibility. Convenience in classes implementing the interface
=======================
    1:  public enum AnimalClasses {
        2:     MAMMAL(true), INVERTIBRATE(Boolean.FALSE), BIRD(false),
        3:     REPTILE(false), AMPHIBIAN(false), FISH(false) {
        4:        public int swim() { return 4; }
        5:     }
        6:     final boolean hasHair;
        7:     public AnimalClasses(boolean hasHair) {
        8:        this.hasHair = hasHair;
        9:     }
        10:    public boolean hasHair() { return hasHair; }
        11:    public int swim() { return 0; }
        12: }
// compiler errors on row 5 and 7 !!!!!!!!
row 5: missing ;
row 7: Enum constructors are implicitly private;
===================================================
CHAPTER 13 ANNOTATIONS
====================================================

annotations provide an easy and convenient way to insert metadata like this into your applications.
The purpose of an annotation is to assign metadata attributes to classes, methods, variables, and other Java types
annotations function a lot like interfaces.
unlike interfaces, annotations allow us to pass a set of values where they are applied.
public class Veterinarian {
   @ZooAnimal(habitat="Infirmary") private Lion sickLion;

   @ZooAnimal(habitat="Safari") private Lion healthyLion;

   @ZooAnimal(habitat="Special Enclosure") private Lion blindLion;
}
annotations establish relationships that make it easier to manage data about our application.
annotations are optional metadata and by themselves do not do anything.
This means you can take a project filled with thousands of annotations and remove all of them, and it will still compile and run, albeit with potentially different behavior at runtime
While an annotation can be removed from a class and it will still compile, the opposite is not true; adding an annotation can trigger a compiler error. As we will see in this chapter, the compiler validates that annotations are properly used and include all required fields.
Creating your own annotation is surprisingly easy. You just give it a name, define a list of optional and required elements, and specify its usage.
We use the @interface annotation (all lowercase) to declare an annotation. Like classes and interfaces, they are commonly defined in their own file as a top‐level type, although they can be defined inside a class declaration like an inner class.
public @interface Exercise {}
The Exercise annotation is referred to as a marker annotation, since it does not contain any elements.
@Exercise() public class Cheetah {}
@Exercise public class Sloth {}
@Exercise
public class ZooEmployee {}
Like interfaces, annotations can be applied to unrelated classes.
Cheetah uses parentheses, (), while the Sloth does not. When using a marker annotation, parentheses are optional. Once we start adding elements, though, they are required if the annotation includes any values.
 is common practice to have them start with an uppercase letter, although it is not required.
 let's change @Exercise from a marker annotation to one that includes an element.
public @interface Exercise {
   int hoursPerDay();
}
annotations have their roots in interfaces. Behind the scenes, the JVM is creating elements as interface methods and annotations as implementations of these interfaces

@Exercise(hoursPerDay=3) public class Cheetah {}

@Exercise hoursPerDay=0 public class Sloth {}     // DOES NOT COMPILE

@Exercise public class ZooEmployee {}             // DOES NOT COMPILE
While the annotation itself is optional, the compiler still cares that they are used correctly.
When declaring an annotation, any element without a default value is considered required. 
public @interface Exercise {
   int hoursPerDay();
   int startHour() default 6;
}
@Exercise(startHour=5, hoursPerDay=3) public class Cheetah {}

@Exercise(hoursPerDay=0) public class Sloth {}

@Exercise(hoursPerDay=7, startHour="8")  // DOES NOT COMPILE
public class ZooEmployee {}

 Similar to case statement values, the default value of an annotation must be a non‐ null constant expression.

    public @interface BadAnnotation {
       String name() default new String("");  // DOES NOT COMPILE
       String address() default "";
       String title() default null;           // DOES NOT COMPILE
    }
Notice that while null is not permitted as a default value, the empty String "" is.
------------------------------------
public class Bear {}

public enum Size {SMALL, MEDIUM, LARGE}

public @interface Panda {
   Integer height(); // doesnt c.
   String[][] generalInfo(); // ?? doesnt compile
   Size size() default Size.SMALL;
   Bear friendlyBear(); //doesnt compile
   Class<? extends Bear> friendlyBear();  // Use Class<?> to refer to Bear class
   Exercise exercise() default @Exercise(hoursPerDay=2);
}
The height() element does not compile. While primitive types like int and long are supported, wrapper classes like Integer and Long are not. The generalInfo() element also does not compile. The type String[] is supported, as it is an array of String values, but String[][] is not.
Finally, the friendlyBear() element does not compile. The type of friendlyBear() is Bear (not Class). Even if Bear were changed to an interface, the friendlyBear() element would still not compile since it is not one of the supported types.
------------------------------------
Like abstract interface methods, annotation elements are implicitly abstract and public, whether you declare them that way or not.
public @interface Material {}

public @interface Fluffy {
   int cuteness();
   public abstract int softness() default 11;
   protected Material material();  // DOES NOT COMPILE
   private String friendly();      // DOES NOT COMPILE
   final boolean isBunny();        // DOES NOT COMPILE
}
-------------------------
public @interface ElectricitySource {
   public int voltage();
   int MIN_VOLTAGE = 2;
   public static final int MAX_VOLTAGE = 18;
}
Yep, just like interface variables, annotation variables are implicitly public, static, and final. These constant variables are not considered elements, though. For example, marker annotations can contain constants
----------------------------
ANNOTATIONS CAN BE APPLIED TO:
Classes, interfaces, enums, and modules

Variables ( static, instance, local)

Methods and constructors

Method, constructor, and lambda parameters

Cast expressions

Other annotations
---------------------------
The following compiles, assuming the annotations referenced in it exist:


1:  @FunctionalInterface interface Speedster {
2:     void go(String name);
3:  }
4:  @LongEars
5:  @Soft @Cuddly public class Rabbit {
6:     @Deprecated public Rabbit(@NotNull Integer size) {}
7:
8:     @Speed(velocity="fast") public void eat(@Edible String input) {
9:        @Food(vegetarian=true) String m = (@Tasty String) "carrots";
10:
11:       Speedster s1 = new @Racer Speedster() {
12:          public void go(@FirstName @NotEmpty String name) {
13:             System.out.print("Start! "+name);
14:          }
15:       };
16:
17:       Speedster s2 = (@Valid String n) -> System.out.print(n);
18:    }}
When applying an annotation to an expression, a cast operation including the Java type is required. On line 9, the expression was cast to String, and the annotation @Tasty was applied to the type.
------------------------------------
 An annotation can specify which declaration type they can be applied to using the @Target annotation. 
------------------------------------------
An annotation must adhere to the following rules to be used without a name:

The annotation declaration must contain an element named value(), which may be optional or required.

The annotation declaration must not contain any other elements that are required.

The annotation usage must not provide values for any other elements.

Let's create an annotation that meets these requirements.


public @interface Injured {
   String veterinarian() default "unassigned";
   String value() default "foot";
   int age() default 1;
}

public abstract class Elephant {
   @Injured("Legs") public void fallDown() {}
   @Injured(value="Legs") public abstract int trip();
   @Injured String injuries[];
}
@Injured("Fur",age=2) public class Bear {}  // DOES NOT COMPILE
----------------------

public class Giraffe {
   @Music(genres={"Rock and roll"}) String mostDisliked;
   @Music(genres="Classical") String favorite;
}
The second annotation is the shorthand notation, where the array braces ( {}) are dropped for convenience. Keep in mind that this is still providing a value for an array element; the compiler is just inserting the missing array braces for you.
-------------------------------------------------
public class Reindeer {
   @Music(genres="Blues","Jazz") String favorite;  // DOES NOT COMPILE
   @Music(genres=) String mostDisliked;            // DOES NOT COMPILE
   @Music(genres=null) String other;               // DOES NOT COMPILE
   @Music(genres={}) String alternate;
}
----------------------------------
  public class Capybara {
       @Rhythm(value={"Swing"}) String favorite;
       @Rhythm(value="R&B") String secondFavorite;
       @Rhythm({"Classical"}) String mostDisliked;
       @Rhythm("Country") String lastDisliked;
    }
------------------------------
 built‐in annotations applied to other annotations. Yes, metadata about metadata! Since these annotations are built into Java, they primarily impact the compiler.
Many annotation declarations include @Target annotation, which limits the types the annotation can be applied to. More specifically, the @Target annotation takes an array of ElementType enum values as its value() element.

Java Annotation Declaration with @Target
The @Target annotation is used to restrict where an annotation can be applied. Without @Target, an annotation can be applied to any program element (class, method, field, etc.). By using @Target, you can specify which elements the annotation can be used on, such as classes, methods, fields, or constructors.

1. @Target Syntax
The @Target annotation takes an array of ElementType enum values, which define the types of elements where the annotation can be applied.

The common ElementType values include:

ElementType.TYPE: for classes, interfaces, enums.
ElementType.FIELD: for fields (variables).
ElementType.METHOD: for methods.
ElementType.PARAMETER: for parameters of methods or constructors.
ElementType.CONSTRUCTOR: for constructors.
ElementType.LOCAL_VARIABLE: for local variables.
ElementType.ANNOTATION_TYPE: for annotations themselves.
ElementType.PACKAGE: for packages.

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

@Target({ElementType.METHOD, ElementType.FIELD})  // Limits where this annotation can be used
public @interface MyCustomAnnotation {
    String value() default "default";
}

@Target(ElementType.TYPE)
public @interface TypeAnnotation {}

@TypeAnnotation
public class MyClass {}
------------
ElementType	Applies to
TYPE	Classes, interfaces, enums, annotations
FIELD	Instance and static variables, enum values
METHOD	Method declarations
PARAMETER	Constructor, method, and lambda parameters
CONSTRUCTOR	Constructor declarations
LOCAL_VARIABLE	Local variables
ANNOTATION_TYPE	Annotations
TYPE_USE	Anywhere a Java type is declared or used
MODULE	Modules
------------------------------------------------

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

@Target({ElementType.METHOD,ElementType.CONSTRUCTOR})
public @interface ZooAttraction {}
Note	
Even though the java.lang package is imported automatically by the compiler, the java.lang.annotation package is not. Therefore, import statements are required for many of the examples in the remainder of this chapter.
----------------------------
TYPE_USE: 
There are a few exceptions; for example, it can be used only on a method that returns a value. Methods that return void would still need the METHOD value defined in the annotation.

It also allows annotations in places where types are used, such as cast operations, object creation with new, inside type declarations, etc. These might seem a little strange at first, but the following are valid TYPE_USE applications:
// Technical.java
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

@Target(ElementType.TYPE_USE)
@interface Technical {}
 
// NetworkRepair.java
import java.util.function.Predicate;
public class NetworkRepair {
   class OutSrc extends @Technical NetworkRepair {}
   public void repair() {
      var repairSubclass = new @Technical NetworkRepair() {};

      var o = new @Technical NetworkRepair().new @Technical OutSrc();

      int remaining = (@Technical int)10.0;
   }
}
-----------------------------
Storing Annotations with @Retention
---------
he compiler discards certain types of information when converting your source code into a .class file. With generics, this is known as type erasure.
annotations may be discarded by the compiler or at runtime. We say “may,” because we can actually specify how they are handled using the @Retention annotation. This annotation takes a value() of the enum RetentionPolicy.

RetentionPolicy	Description
SOURCE	Used only in the source file, discarded by the compiler
CLASS	Stored in the .class file but not available at runtime (default)
RUNTIME	Stored in the .class file and available at runtime


import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.SOURCE)
public @interface MySourceAnnotation {
    String value() default "Source level";
}
This annotation will not be included in the .class file and cannot be accessed at runtime.
-------------------------------------
Generating Javadoc with @Documented
----------------------
 Javadoc is a built‐in standard within Java that generates documentation for a class or API.
 marker annotation @DocumenteD : the generated Javadoc will include annotation information defined on Java types. Because it is a marker annotation, it doesn't take any values; therefore, using it is pretty easy.

Be careful not to confuse Javadoc annotations with the Java annotations. 
 Take a look at the @deprecated and @Deprecated annotations in this example. The first, @deprecated, is a Javadoc annotation used inside a comment, while @Deprecated is a Java annotation applied to a class. Traditionally, Javadoc annotations are all lowercase, while Java annotations start with an uppercase letter.

    public class ZooLightShow {

       /**
        * Performs a light show at the zoo.
        *
        * @param      distance   length the light needs to travel.
        * @return     the result of the light show operation.
        * @author     Grace Hopper
        * @since      1.5
        * @deprecated Use EnhancedZooLightShow.lights() instead.
        */
       @Deprecated(since="1.5") public static String perform(int distance) {
          return "Beginning light show!";
       }
    }
---------------------------------------------
When this annotation is applied to a class, subclasses will inherit the annotation information found in the parent class.


// Vertebrate.java
import java.lang.annotation.Inherited;

@Inherited public @interface Vertebrate {}

// Mammal.java
@Vertebrate public class Mammal {}

// Dolphin.java
public class Dolphin extends Mammal {}
In this example, the @Vertebrate annotation will be applied to both Mammal and Dolphin objects. Without the @Inherited annotation, @Vertebrate would apply only to Mammal instances.
-----------------------------------
The @Repeatable annotation is used when you want to specify an annotation more than once on a type.

Why would you want to specify twice? Well, if it's a marker annotation with no elements, you probably wouldn't. Generally, you use repeatable annotations when you want to apply the same annotation with different values.

Let's assume we have a repeatable annotation @Risk, which assigns a set of risk values to a zoo animal. We'll show how it is used and then work backward to create it.

public class Zoo {
   public static class Monkey {}

   @Risk(danger="Silly")
   @Risk(danger="Aggressive",level=5)
   @Risk(danger="Violent",level=10)
   private Monkey monkey;
}
Next, let's define a simple annotation that implements these elements:


public @interface Risk {
   String danger();
   int level() default 1;
}
Now, as written, the Zoo class does not compile, u need this:

1:
public @interface Risks {
   Risk[] value();
}
2:
import java.lang.annotation.Repeatable;

@Repeatable(Risks.class)
public @interface Risk {
   String danger();
   int level() default 1;
}
3:
public class Zoo {
   public static class Monkey {}

   @Risk(danger="Silly")
   @Risk(danger="Aggressive", level=5)
   @Risk(danger="Violent", level=10)
   private Monkey monkey;
}

The repeatable annotation must be declared with @Repeatable and contain a value that refers to the containing type annotation.

The containing type annotation must include an element named value(), which is a primitive array of the repeatable annotation type.
----------------------------------------------------

Annotation	Marker Annotation	Type of value()	Default Behavior if Not Present
@Target	         No	             Array of ElementType	Applies to all locations except TYPE_USE and TYPE_PARAMETER
@Retention	No	RetentionPolicy	RetentionPolicy.CLASS
@Documented	Yes	—	Annotations are not included in generated Javadoc
@Inherited	Yes	—	Annotations in supertypes are not inherited
@Repeatable	No	Annotation	Annotation cannot be repeated
--------------------------------------

 without the @Documented or @Inherited annotation, these features are not supported. Likewise, the compiler will report an error if you try to use an annotation more than once without the @Repeatable annotation.
------------------------------------

 The @Deprecated annotation is similar to a marker annotation, in that it can be used without any values, but it includes some optional elements. The @Deprecated annotation can be applied to nearly any Java declaration, such as classes, methods, or variables.
---------------------------------
/**
 * Design and plan a zoo.
 * @deprecated Use ParkPlanner instead.
 */
@Deprecated
public class ZooPlanner { ... }

The users of the ZooPlanner class will now receive a compiler warning if they are using ZooPlanner
----------------------------------
 the @Deprecated annotation does support two optional values: String since() and boolean forRemoval(). They provide additional information about when the deprecation occurred in the past and whether or not the type is expected to be removed entirely in the future.


/**
 * Method to formulate a zoo layout.
 * @deprecated Use ParkPlanner.planPark(String... data) instead.
 */
@Deprecated(since="1.8", forRemoval=true)
public void plan() {}
---------------------------------------------
Value	Description
"deprecation"	Ignore warnings for types or methods marked with the @Deprecated annotation.
"unchecked"	Ignore warnings for the use of raw types, such as List instead of List<String>.
public class Example {
    @SuppressWarnings("deprecation")  // Suppresses the deprecation warning
    public void useDeprecatedMethod() {
        DeprecatedClass obj = new DeprecatedClass();
        obj.deprecatedMethod();  // Deprecated, but no warning will show
    }
}

import java.util.List;
import java.util.ArrayList;

public class Example {
    @SuppressWarnings("unchecked")  // Suppresses unchecked warning for raw type usage
    public void useRawTypes() {
        List list = new ArrayList();  // Raw type usage
        list.add("Some string");
    }
}

@SuppressWarnings({"deprecation", "unchecked"})
public void useDeprecatedAndRawTypes() {
    DeprecatedClass obj = new DeprecatedClass();
    obj.deprecatedMethod();  // Deprecated method
    List list = new ArrayList();  // Raw type
    list.add("Another string");
}

A raw type in Java refers to a generic class or interface without specifying a type parameter. Raw types were used before Java introduced generics (in Java 5), and they allow you to work with generics without specifying the specific data type.

When you use a raw type, you're essentially telling the compiler to ignore the type parameter, which can lead to warnings because you lose the benefits of type safety that generics provide.
-------------------------
The @SafeVargs marker annotation indicates that a method does not perform any potential unsafe operations on its varargs parameter. It can be applied only to constructors or methods that cannot be overridden (aka methods marked private, static, or final).
-----------------------------

@SafeVargs, the annotation is used to indicate to other developers that your method does not perform any unsafe operations. It basically tells other developers, “Don't worry about the varargs parameter; I promise this method won't do anything bad with it!” It also suppresses unchecked compiler warnings for the varargs parameter.
------------------------------
1:  import java.util.*;
2:
3:  public class NeverDoThis {
4:     final int thisIsUnsafe(List<Integer>... carrot) {
5:        Object[] stick = carrot;
6:        stick[0] = Arrays.asList("nope!");
7:        return carrot[0].get(0);  // ClassCastException at runtime
8:     }
9:     public static void main(String[] a) {
10:       var carrot = new ArrayList<Integer>();
11:       new NeverDoThis().thisIsUnsafe(carrot);
12:    }
13: }
This code compiles, although it generates two compiler warnings. Both are related to type safety.

3:     @SafeVarargs final int thisIsUnsafe(List<Integer>... carrot) {
Did we actually fix the unsafe operation? No! It still throws a ClassCastException at runtime on line 7

[Line 4]  Type safety: Potential heap pollution via varargs
   parameter carrot
[Line 11] Type safety: A generic array of List<Integer> is created
   for a varargs parameter
We can remove both compiler warnings by adding the @SafeVarargs annotation to line 4.

stick[0] = Arrays.asList("nope!");
The stick array is treated as a raw Object[], and you assign a List<String> (Arrays.asList("nope!")) into it. This causes heap pollution because carrot is expected to be a List<Integer>[], but it now contains a List<String>.

return carrot[0].get(0);
You get a ClassCastException at runtime because it was actually a String, not an Integer.

To remove these warnings, you can use the @SafeVarargs annotation. This tells the compiler that you, as the programmer, guarantee that the varargs won't cause heap pollution and the method is safe to use.
------------------------
You should also know the annotation can be applied only to methods that contain a varargs parameter and are not able to be overridden. For example, the following do not compile:


@SafeVarargs
public static void eat(int meal) {}         // DOES NOT COMPILE

@SafeVarargs
protected void drink(String... cup) {}      // DOES NOT COMPILE

@SafeVarargs void chew(boolean... food) {}  // DOES NOT COMPILE
The eat() method is missing a varargs parameter, while the drink() and chew() methods are not marked static, final, or private.
------------------------------

@Override: Marker annotation, no value, no optional members.
@FunctionalInterface: Marker annotation, no value, no optional members.
@Deprecated: Not a marker annotation, no value, optional members: String since(), boolean forRemoval().
@SuppressWarnings: Not a marker annotation, String[] value, no optional members.
@SafeVarargs: Marker annotation, no value, no optional members.
------------------------------------------------------------------------
This is commonly referred to as a single-element annotation or marker annotation with a value.

Example:
java
Copy code
public @interface MyAnnotation {
    String value();  // Element must be named 'value'
}
Now you can use the annotation without specifying value:

java
Copy code
@MyAnnotation("Hello")  // No need to write 'value = "Hello"'
public class MyClass {}
------------------------------------






































































































































































































======================




























































