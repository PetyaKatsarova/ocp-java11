=========== MODULES ===================
The Java Platform Module System (JPMS) was introduced in Java 9 to group code at a higher level and tries to solve the problems that Java has been plagued with since the beginning. The main purpose of a module is to provide groups of related packages to offer a particular set of functionality to developers. It’s like a JAR file except a developer chooses which packages are accessible outside the module. Let’s look at what modules are and what problems they are designed to solve.

The Java Platform Module System includes the following:
A format for module JAR files
Partitioning of the JDK into modules
Additional command-line options for Java tools
=========================
A module is a group of one or more packages plus a special file called module-info .java.
----------------
the JUnit 4 testing library depends on the Hamcrest library for matching logic. 
===================
The Java Development Kit (JDK) is larger than 150 MB. Even the Java Runtime Environment (JRE) was pretty big when it was available as a separate download.
=======================
The Java Platform Module System allows developers to specify what modules they actually need. This makes it possible to create a smaller runtime image that is customized to what the application needs and nothing more. Users can run that image without having Java installed at all.
================================
A tool called jlink is used to create this runtime image. Luckily, you only need to know that custom smaller runtimes are possible.
In addition to the smaller scale package, this approach improves security. If you don’t use AWT and a security vulnerability is reported for AWT, applications that packaged a runtime image without AWT aren’t affected.
===============
Improved Performance
Since Java now knows which modules are required, it only needs to look at those at class loading time. This improves startup time for big programs and requires less memory to run.
==============
The Java Platform Module System prevents this scenario. A package is only allowed to be supplied by one module. No more unpleasant surprises about a package at runtime.
===========
key differences between a module-info file and a regular Java class:
The module-info file must be in the root directory of your module. Regular Java classes should be in packages.
The module-info file must use the keyword module instead of class, interface, or enum.
The module name follows the naming rules for package names. It often includes periods (.) in its name. Regular class and package names are not allowed to have dashes (-). Module names follow the same rule.
========================================
package zoo.animal.feeding;
 
public class Task {
   public static void main(String... args) {
      System.out.println("All fed!");
   }
}
Next comes the module-info.java file. This is the simplest possible one.


module zoo.animal.feeding {
}
===================== can be empty module and file
 it was legal to compile any empty file with a .java extension even before modules. The compiler sees there isn’t a class in there and exits without creating a .class file.
==================================
compiles all .java files in the feeding/zoo/animal/feeding/ directory as well as the module-info.java file. The compiled output (the .class files) will be placed inside the feeding directory, while the mods directory will be used to locate other module dependencies during compilation:

javac -p mods -d feeding feeding/zoo/animal/feeding/*.java feeding/module-info.java
jar -cvf mods/zoo.animal.feeding.jar -C feeding/ .
# jar: Java archiving tool
# -c: Create JAR
# -v: Verbose output (show process)
# -f mods/zoo.animal.feeding.jar: JAR output file
# -C feeding/: Change directory to feeding/
# .: Include all files from feeding/ directory in the JAR
======================================

// HippoBirthday.java
package zoo.animal.care.details;
import zoo.animal.feeding.*;
public class HippoBirthday {
   private Task task;
}
 
// Diet.java
package zoo.animal.care.medical;
public class Diet { }
This time the module-info.java file specifies three things.

1: module zoo.animal.care {
2:    exports zoo.animal.care.medical;
3:    requires zoo.animal.feeding;
4: }
==============================================
javac -p mods
   -d care
   care/zoo/animal/care/details/*.java
   care/zoo/animal/care/medical/*.java
   care/module-info.java

jar -cvf mods/zoo.animal.care.jar -C care/ .

======================================
exports, requires, provides, uses, and opens. Now would be a good time to mention that these keywords can appear in any order in the module-info file.  These “keywords” are only keywords inside a module-info .java file.
 In other files, like classes and interfaces, you are free to name your variable exports. These special keywords are called directives.
================================
module zoo.animal.talks {
   exports zoo.animal.talks.content to zoo.staff;
   exports zoo.animal.talks.media;
   exports zoo.animal.talks.schedule;
 
   requires zoo.animal.feeding;
   requires zoo.animal.care;
}
From the zoo.staff module, nothing has changed. However, no other modules would be allowed to access that package.
=======================
As you saw earlier in this chapter, requires moduleName specifies that the current module depends on moduleName. There’s also a requires transitive moduleName, which means that any module that requires this module will also depend on moduleName.
When you declare a module, you can specify its dependencies using the requires directive. If module A depends on module B, you would write requires B; in module A's module declaration.

However, sometimes you want the dependencies of B to be visible to any module that depends on A. This is where requires transitive comes in. If you declare requires transitive B; in module A, it means that A's consumers (modules that depend on A) will also automatically depend on B.
============
requires: Makes a dependency available only to the current module.
requires transitive: Makes a dependency available not only to the current module but also to any modules that depend on it.
===========
For the remaining three keywords (provides, uses, and opens), you only need to be aware they exist rather than understanding them in detail for the 1Z0-815 exam
=============
The provides keyword specifies that a class provides an implementation of a service. The topic of services is covered on the 1Z0-816 exam, so for now, you can just think of a service as a fancy interface. To use it, you supply the API and class name that implements the API:
provides zoo.staff.ZooApi with zoo.staff.ZooImpl
The uses keyword specifies that a module is relying on a service. To code it, you supply the API you want to call:
uses zoo.staff.ZooApi
=================================
Java allows callers to inspect and call code at runtime with a technique called reflection
This is a powerful approach that allows calling code that might not be available at compile time. It can even be used to subvert access control! 
Since reflection can be dangerous, the module system requires developers to explicitly allow reflection in the module-info if they want calling modules to be allowed to use it. Here are two examples:
opens zoo.animal.talks.schedule;
opens zoo.animal.talks.media to zoo.staff;
The first example allows any module using this one to use reflection. The second example only gives that privilege to the zoo.staff package.
=================================
The java command has three module-related options. One describes a module, another lists the available modules, and the third shows the module resolution logic.
==================================
Suppose you are given the zoo.animal.feeding module JAR file and want to know about its module structure. You could “unjar” it and open the module-info file. This would show you that the module exports one package and doesn’t require any modules.


module zoo.animal.feeding {
   exports zoo.animal.feeding;
}
However, there is an easier way. The java command now has an option to describe a module. The following two commands are equivalent:


java -p mods
   -d zoo.animal.feeding
 
java -p mods
   --describe-module zoo.animal.feeding
Each prints information about the module. For example, it might print this:


zoo.animal.feeding file:///absolutePath/mods/zoo.animal.feeding.jar
exports zoo.animal.feeding
requires java.base mandated
-d:  --describe-module.
-p:  --module-path
mods is the directory where compiled modules are stored.

!! NB !! ======================
java -p mods -d zoo.animal.feeding
java -p mods --describe-module zoo.animal.feeding
================================

are equivalent, and both will describe the zoo.animal.feeding module by searching for it in the mods directory.
output:
zoo.animal.feeding file:///absolutePath/mods/zoo.animal.feeding.jar
exports zoo.animal.feeding
requires java.base mandated
===============
The java.base module is special. It is automatically added as a dependency to all modules. This module has frequently used packages like java.util. That’s what the mandated is about. You get java.base whether you asked for it or not.It is automatically available to all other modules.
=================

java -p mods -d zoo.animal.care


zoo.animal.care file:///absolutePath/mods/zoo.animal.care.jar
requires zoo.animal.feeding transitive
requires java.base mandated
qualified exports zoo.animal.care.medical to zoo.staff
contains zoo.animal.care.details
The first line of the output is the absolute path of the module file. The two requires lines should look familiar as well. The first is in the module-info, and the other is added to all modules. Next comes something new. The qualified exports is the full name of exporting to a specific module.

Finally, the contains means that there is a package in the module that is not exported at all. This is true. Our module has two packages, and one is available only to code inside the module.
==============================
In addition to describing modules, you can use the java command to list the modules that are available. The simplest form lists the modules that are part of the JDK:

java --list-modules

When we ran it, the output went on for 70 lines and looked like this:

java.base@11.0.2
java.compiler@11.0.2
java.datatransfer@11.0.2
======================================

java -p mods --list-modules
How many lines do you expect to be in the output this time? There are 74 lines now: the 70 built-in modules plus the four in our zoo system. The custom lines look like this:

zoo.animal.care file:///absolutePath/mods/zoo.animal.care.jar
zoo.animal.feeding file:///absolutePath/mods/zoo.animal.feeding.jar
zoo.animal.talks file:///absolutePath/mods/zoo.animal.talks.jar
zoo.staff file:///absolutePath/mods/zoo.staff.jar
================================

java --show-module-resolution
   -p feeding
   -m zoo.animal.feeding/zoo.animal.feeding.Task

Luckily you don’t need to understand this output. That said, having seen it will make it easier to remember. Here’s a snippet of the output:


root zoo.animal.feeding file:///absolutePath/feeding/
java.base binds java.desktop jrt:/java.desktop
java.base binds jdk.jartool jrt:/jdk.jartool
...
jdk.security.auth requires java.naming jrt:/java.naming
jdk.security.auth requires java.security.jgss jrt:/java.security.jgss
...
All fed!
It starts out by listing the root module. That’s the one we are running: zoo.animal .feeding. Then it lists many lines of packages included by the mandatory java.base module. After a while, it lists modules that have dependencies. Finally, it outputs the result of the program All fed!. The total output of this command is 66 lines.
=====================

jar -f mods/zoo.animal.feeding.jar -d
jar --file mods/zoo.animal.feeding.jar --describe-module
The output is slightly different from when we used the java command to describe the module. With jar, it outputs the following:

zoo.animal.feeding jar:file:///absolutePath/mods/zoo.animal.feeding.jar /!module-info.class
exports zoo.animal.feeding
requires java.base mandated

====================

The jdeps command gives you information about dependencies within a module. Unlike describing a module, it looks at the code in addition to the module-info file. This tells you what dependencies are actually used rather than simply declared.

jdeps -s mods/zoo.animal.feeding.jar
jdeps -summary mods/zoo.animal.feeding.jar

Notice that there is one dash (-) before -summary rather than two. Regardless, the output tells you that there is only one package and it depends on the built-in java.base module.
zoo.animal.feeding -> java.base

Alternatively, you can call jdeps without the summary option and get the long form:


jdeps mods/zoo.animal.feeding.jar
[file:///absolutePath/mods/zoo.animal.feeding.jar]
   requires mandated java.base (@11.0.2)
zoo.animal.feeding -> java.base
   zoo.animal.feeding         -> java.io
      java.base
   zoo.animal.feeding         -> java.lang
      java.base
==============================
jdeps -s
   --module-path mods
   mods/zoo.animal.care.jar
 
jdeps -summary
   --module-path mods
   mods/zoo.animal.care.jar
There is not a short form of --module-path in the jdeps command. The output is only two lines:


zoo.animal.care -> java.base
zoo.animal.care -> zoo.animal.feeding
=====================

jdeps --module-path mods
   mods/zoo.animal.care.jar
This time we get lots of output:
zoo.animal.care
   [file:///absolutePath/mods/zoo.animal.care.jar]
      requires mandated java.base (@11.0.2)
      requires transitive zoo.animal.feeding
   zoo.animal.care -> java.base
   zoo.animal.care -> zoo.animal.feeding
      zoo.animal.care.details     -> java.lang                                        
         java.base
      zoo.animal.care.details     -> zoo.animal.feeding                                
         zoo.animal.feeding
      zoo.animal.care.medical     -> java.lang                                        
         java.base

=============================
The final command you need to know for the exam is jmod. You might think a JMOD file is a Java module file. Not quite. Oracle recommends using JAR files for most modules. JMOD files are recommended only when you have native libraries or something that can’t go inside a JAR file. This is unlikely to affect you in the real world.

The most important thing to remember is that jmod is only for working with the JMOD files. Conveniently, you don’t have to memorize the syntax for jmod. Table 11.4 lists the common modes.
========================
Table 11.4: Modes using jmod
Operation

Description

create

Creates a JMOD file.

extract

Extracts all files from the JMOD. Works like unzipping.

describe

Prints the module details such as requires.

list

Lists all files in the JMOD file.

hash

Shows a long string that goes with the file
======================

Description                                                                                                Syntax
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
Compile nonmodular code                                                                   javac -cp classpath -d directory classesToCompile

                                                                                          javac --class-path classpath -d directory classesToCompile

                                                                                          javac -classpath classpath -d directory classesToCompile
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Run nonmodular code                                                                      java -cp classpath package.className

                                                                                         java -classpath classpath package.className

                                                                                         java --class-path classpath package.className
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Compile a module                                                                         javac -p moduleFolderName -d directory classesToCompileIncludingModuleInfo

                                                                                         javac --module-path moduleFolderName -d directory classesToCompileIncludingModuleInfo
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Run a module                                                                             java -p moduleFolderName -m moduleName/package.className

                                                                                         java --module-path moduleFolderName --module moduleName/package.className
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Describe a module                                                                        java -p moduleFolderName -d moduleName

                                                                                         java --module-path moduleFolderName --describe-module moduleName

                                                                                         jar --file jarName --describe-module

                                                                                         jar -f jarName -d
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
List available modules                                                                   java --module-path moduleFolderName --list-modules

                                                                                         java -p moduleFolderName --list-modules

                                                                                         java --list-modules
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
View dependencies                                                                        jdeps -summary --module-path moduleFolderName jarName

                                                                                         jdeps -s --module-path moduleFolderName jarName
--------------------------------------------------------------------------------------------------------------------------------------------------------------
Show module resolution                                                                   java --show-module-resolution -p moduleFolderName -m moduleName

                                                                                         java --show-module-resolution --module-path moduleFolderName --module moduleName
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
=========================
Options you need to know for the exam: javac
==================================================
-cp <classpath>
-classpath <classpath>
--class-path <classpath>                  Location of JARs in a nonmodular program
-----------------------------------------------------------------
-d <dir>                                  Directory to place generated class files
----------------------------------------------------------------------------
-p <path>
--module-path <path>                       Location of JARs in a modular program
------------------------------------------------------------------------------------------
==============================
Options you need to know for the exam: java
=============================================================================================
Option                                                        Description

-p <path>
--module-path <path>                                    Location of JARs in a modular program
------------------------------------------------------------------------------
-m <name>
--module <name>                                         Module name to run
------------------------------------------------------------------
-d
--describe-module                                      Describes the details of a module
--------------------------------------------------------------------------------
--list-modules                                        Lists observable modules without running a program
------------------------------------------------------------------------------
--show-module-resolution                             Shows modules when running program
-----------------------------------------------------------------------------------------------
===============================================
Table 11.8: Options you need to know for the exam: jar
==========================================================
Option                     Description

-c
--create                Create a new JAR file
---------------------------------------
-v
--verbose              Prints details when working with JAR files
-------------------------------------
-f
--file                 JAR filename
-------------------------------------------------
-C                  Directory containing files to be used to create the JAR
-----------------------------------------------------------
-d
--describe-module      Describes the details of a module
------------------------------------------------------------
==============================
Table 11.9: Options you need to know for the exam: jdeps
===============================================
Option                Description
--module-path <path>    Location of JARs in a modular program
-----------------------------
-s
-summary       Summarizes output
---------------------------------------
The Java Platform Module System organizes code at a higher level than packages. 
==========================
!! NB !!
==========================
The Java Platform Module System organizes code at a higher level than packages. Each module contains one or more packages and a module-info file. Advantages of the JPMS include better access control, clearer dependency management, custom runtime images, improved performance, and unique package enforcement.

The process of compiling and running modules uses the --module-path, also known as -p. Running a module uses the --module option, also known as -m. The class to run is specified in the format moduleName/className.

The module-info file supports a number of keywords. The exports keyword specifies that a package should be accessible outside the module. It can optionally restrict that export to a specific package. The requires keyword is used when a module depends on code in another module. Additionally, requires transitive can be used when all modules that require one module should always require another. The provides and uses keywords are used when sharing and consuming an API. Finally, the opens keyword is used for allowing access via reflection.

Both the java and jar commands can be used to describe the contents of a module. The java command can additionally list available modules and show module resolution. The jdeps command prints information about packages used in addition to module-level information. Finally, the jmod command is used when dealing with files that don’t meet the requirements for a JAR.
==========================================
a.A central repository of all modules

b.Encapsulating packages

c.Encapsulating objects

d.No defined types

e.Platform independence

Option B is correct since modules allow you to specify which packages can be called by external code.(ENCAPSULATION) Options C and E are incorrect because they are provided by Java without the module system. Option A is incorrect because there is not a central repository of modules. Option D is incorrect because Java defines types.
=============================================
!! NB !!
 opens is for reflection and uses declares an API that consumes a service:

The opens keyword allows the use of reflection.
The uses keyword declares an API is called.
The file can be empty (zero bytes).
============================================================
B, C. Packages inside a module are not exported by default, making option B correct and option A incorrect. Exporting is necessary for other code to use the packages; it is not necessary to call the main() method at the command line, making option C correct and option D incorrect. The module-info.java file has the correct name and compiles, making options E and F incorrect.
========================
Which commands take a --module-path parameter? (Choose all that apply.)

javac

java

jar

jdeps

jmod

None of the above

Answer:
A, B, D. Options A and B are correct because the -p (--module-path) option can be passed when compiling or running a program. Option D is also correct because jdeps can use the --module-path option when listing dependency information
========================
--show-module-resolution option? -  The java command uses this option to print information when the program loads. You might think jar does the same thing since it runs a program too. Alas, this parameter does not exist on jar.
====================================
When running java with the -d option, all the required modules are listed. Additionally, the java.base module is listed since it is included automatically. The line ends with mandated, making option A correct. The java.lang is a trick since that is a package that is imported by default in a class rather than a module.
=========================================
the java command has an --add-exports option that allows exporting a package at runtime. However, it is not encouraged to use it.
================================
jdeps -s flea.jar

jdeps -summary flea.jar
========================
Module names look a lot like package names. Each segment is separated by a period (.) and uses characters valid in Java identifiers. identifiers are not allowed to begin with numbers,  Dashes (-) are not allowed either
com.book
com.book$
======================================
 Option A is incorrect because describe-module has the d equivalent. Option C is incorrect because module has the m equivalent. Option D is incorrect because module-path has the p equivalent. Option F is incorrect because summary has the s equivalent. Options B and E are the correct answers because they do not have equivalents.
describe-module
which doesnt have abbreviation?
list-modules

module

module-path

show-module-resolution

summary
============================
CHAPTER 12: JAVA FUNDAMENTALS
=======================
marking a variable final means the value cannot be changed after it is assigned. 
private void printZooInfo(boolean isWeekend) {
   final int giraffe = 5;
   final long lemur;
   if(isWeekend) lemur = 5;
   else lemur = 10;
   System.out.println(giraffe+" "+lemur);
}
As shown with the lemur variable, we don't need to assign a value when a final variable is declared. The rule is only that it must be assigned a value before it can be used.
=================================
The compiler does not allow the use of local variables that may not have been assigned a value, whether they are marked final or not.
===================
Just because a variable reference is marked final does not mean the object associated with it cannot be modified. Consider the following code snippet:

final StringBuilder cobra = new StringBuilder();
cobra.append("Hssssss");
cobra.append("Hssssss!!!");
In the cobra example, the object reference is constant, but that doesn't mean the data in the class is constant.
============================
Instance and static class variables can also be marked final. If an instance variable is marked final, then it must be assigned a value when it is declared or when the object is instantiated. Like a local final variable, it cannot be assigned a value more than once, though
-----------------------
public class PolarBear {
   final int age = 10;
   final int fishEaten;
   final String name;

   { fishEaten = 10; }

   public PolarBear() {
      name = "Robert";
   }
   public PolarBear(int height) {
      this();
   }
}
===========================
Methods marked final cannot be overridden by a subclass. Marking a method or class final means it cannot be overridden or extended, respectively.
Enum values are considered constants and are commonly written using snake case, often stylized as snake_case. This style uses an underscore ( _) to separate words with constant values commonly written in all uppercase. For example, an enum declaring a list of ice cream flavors might include values like VANILLA, ROCKY_ROAD, MINT_CHOCOLATE_CHIP, and so on.
Behind the scenes, an enum is a type of class that mainly contains static members. It also includes some helper methods like name().
Season s = Season.SUMMER;
System.out.println(Season.SUMMER); // SUMMER
System.out.println(s == Season.SUMMER); // true
--------------------------------
An enum provides a values() method to get an array of all of the values. 
for(Season season: Season.values()) {
   System.out.println(season.name() + " " + season.ordinal());
}
The output shows that each enum value has a corresponding int value, and the values are listed in the order in which they are declared.
--------------------------------
You can't compare an int and enum value directly anyway since an enum is a type, like a Java class, and not a primitive int.
if ( Season.SUMMER == 2) {} // DOES NOT COMPILE
-----------------------
Season s = Season.valueOf("SUMMER"); // SUMMER
Season t = Season.valueOf("summer"); // Throws an exception at runtime
---------------------------------
Season summer = Season.SUMMER;
switch (summer) {
   case WINTER:
      System.out.println("Get out the sled!");
      break;
   case SUMMER:
      System.out.println("Time for the pool!");
      break;
   default:
      System.out.println("Is it summer yet?");
}
---------------------
switch (summer) {
   case Season.FALL:  // DOES NOT COMPILE
      System.out.println("Rake some leaves!");
      break;
   case 0:            // DOES NOT COMPILE
      System.out.println("Get out the sled!");
      break;
}
------------------
1: public enum Season {
2:    WINTER("Low"), SPRING("Medium"), SUMMER("High"), FALL("Medium");
3:    private final String expectedVisitors;
4:    private Season(String expectedVisitors) {
5:       this.expectedVisitors = expectedVisitors;
6:    }
7:    public void printExpectedVisitors() {
8:       System.out.println(expectedVisitors);
9:    } }

public static void main(String[] args) {
        System.out.println("winter: " + Season.WINTER);
        System.out.println("vals: " + Arrays.toString(Season.values()));
        Season.SUMMER.printExpectedVisitors();
    }
    output:
    winter: WINTER
    vals: [WINTER, SPRING, SUMMER, FALL]
    High
    ----------------------
    for(Season season: Season.values()) {
       System.out.println(season.name() + " " + season.ordinal());
    }
    The output shows that each enum value has a corresponding int value, and the values are listed in the order in which they are declared.
    WINTER 0
    SPRING 1
    SUMMER 2
    FALL 3
    You can't compare an int and enum value directly anyway since an enum is a type, like a Java class, and not a primitive int.
     if ( Season.SUMMER == 2) {} // DOES NOT COMPILE

Season s = Season.valueOf("SUMMER"); // SUMMER
Season t = Season.valueOf("summer"); // Throws an exception at runtime
-------------------------
Season summer = Season.SUMMER;
switch (summer) {
   case WINTER:
      System.out.println("Get out the sled!");
      break;
   case SUMMER:
      System.out.println("Time for the pool!");
      break;
   default:
      System.out.println("Is it summer yet?");
}

switch (summer) {
   case Season.FALL:  // DOES NOT COMPILE
      System.out.println("Rake some leaves!");
      break;
   case 0:            // DOES NOT COMPILE
      System.out.println("Get out the sled!");
      break;
}
===========================================
!! NB !!
All enum constructors are implicitly private, with the modifier being optional. This is reasonable since you can't extend an enum and the constructors can be called only within the enum itself. An enum constructor will not compile if it contains a public or protected modifier.
=====================================================

How do we call an enum method? It's easy: Season.SUMMER.printExpectedVisitors();
------------------------
public enum OnlyOne {
   ONCE(true);
   private OnlyOne(boolean b) {
      System.out.print("constructing,");
   }
}

public class PrintTheOne {
   public static void main(String[] args) {
      System.out.print("begin,");
      OnlyOne firstCall = OnlyOne.ONCE;  // prints constructing,
      OnlyOne secondCall = OnlyOne.ONCE; // doesn't print anything
      System.out.print("end");
   }
}
----------------------------
public enum Season {
   WINTER {
      public String getHours() { return "10am-3pm"; }
   },
   SPRING {
      public String getHours() { return "9am-5pm"; }
   },
   SUMMER {
      public String getHours() { return "9am-7pm"; }
   },
   FALL {
      public String getHours() { return "9am-5pm"; }
   };
   public abstract String getHours();
}

If we don't want each and every enum value to have a method, we can create a default implementation and override it only for the special cases.


public enum Season {
   WINTER {
      public String getHours() { return "10am-3pm"; }
   },
   SUMMER {
      public String getHours() { return "9am-7pm"; }
   },
   SPRING, FALL;
   public String getHours() { return "9am-5pm"; }
}
===================================
NESTED CLASSES
===================================================
A nested class is a class that is defined within another class. A nested class can come in one of four flavors.
Inner class: A non‐ static type defined at the member level of a class
Static nested class: A static type defined at the member level of a class
Local class: A class defined within a method body
Anonymous class: A special case of a local class that does not have a name
---------------
 interfaces and enums can be declared as both inner classes and static nested classes, but not as local or anonymous classes.
------------------------------------------------
============ NB =====================
INNER NON STATIC CLASS: Can be declared public, protected, package‐private (default), or private
Can extend any class and implement interfaces
Can be marked abstract or final
nb !!!! Cannot declare static fields or methods, except for static final fields
Can access members of the outer class including private members
=========================
20:    public static void main(String[] args) {
21:       Outer outer = new Outer();
22:       Inner inner = outer.new Inner(); // create the inner class
23:       inner.go();
24:    }
===================================
1:  public class A {
2:     private int x = 10;
3:     class B {
4:        private int x = 20;
5:        class C {
6:           private int x = 30;
7:           public void allTheX() {
8:              System.out.println(x);        // 30
9:              System.out.println(this.x);   // 30
10:             System.out.println(B.this.x); // 20
11:             System.out.println(A.this.x); // 10
12:    } } }
13:    public static void main(String[] args) {
14:       A a = new A();
15:       A.B b = a.new B();
16:       A.B.C c = b.new C();
17:       c.allTheX();
18: }}
===================================
    public class Fox {
       private class Den {}
       public void goHome() {
          new Den();
       }
       public static void visitFriend() {
          new Den();  // DOES NOT COMPILE; need to mention new Fox
       }
    }

    public class Squirrel {
       public void visitFox() {
          new Den();  // DOES NOT COMPILE: private and would've needed to add new Fox()
       }
    }
===============================
A static nested class is a static type defined at the member level. Unlike an inner class, a static nested class can be instantiated without an instance of the enclosing class.The trade‐off, though, is it can't access instance variables or methods in the outer class directly. It can be done but requires an explicit reference to an outer class variable. The enclosing class can refer to the fields and methods of the static nested class.
1: public class Enclosing {
2:    static class Nested {
3:       private int price = 6;
4:    }
5:    public static void main(String[] args) {
6:       Nested nested = new Nested();
7:       System.out.println(nested.price);
8: } }
Line 6 instantiates the nested class. Since the class is static, you do not need an instance of Enclosing to use it. You are allowed to access private instance variables, which is shown on line 7.
--------------------------------
 // Toucan.java
    package bird;
    public class Toucan {
       public static class Beak {}
    }

    // BirdWatcher.java
    package watcher;
    import bird.Toucan.Beak; // regular import ok
    import static bird.Toucan.Beak; // this works too
    public class BirdWatcher {
       Beak beak;
    }
-------------------------------
A local class is a nested class defined within a method. Like local variables, a local class declaration does not exist until the method is invoked, and it goes out of scope when the method returns. 
Local classes have the following properties:
They do not have an access modifier.
They cannot be declared static and cannot declare static fields or methods, except for static final fields.
They have access to all fields and methods of the enclosing class (when defined in an instance method).
They can access local variables if the variables are final or effectively final.
==================================================
Anonymous classes are required to extend an existing class or implement an existing interface. They are useful when you have a short implementation that will not be used anywhere else. Here's an example:
1:  public class ZooGiftShop {
2:     abstract class SaleTodayOnly {
3:        abstract int dollarsOff();
4:     }
5:     public int admission(int basePrice) {
6:        SaleTodayOnly sale = new SaleTodayOnly() {
7:           int dollarsOff() { return 3; }
8:        };  // !!! NB !!!	 Don't forget the semicolon!
9:        return basePrice - sale.dollarsOff();
10: } }
!!  Local variable declarations are required to end with semicolons, just like other Java statements—even if they are long and happen to contain an anonymous class.
==========================================
1:  public class ZooGiftShop {
2:     interface SaleTodayOnly {
3:        int dollarsOff();
4:     }
5:     public int admission(int basePrice) {
6:        SaleTodayOnly sale = new SaleTodayOnly() {
7:           public int dollarsOff() { return 3; }
8:        };
9:        return basePrice - sale.dollarsOff();
10: } }
The most interesting thing here is how little has changed. Lines 2 through 4 declare an interface instead of an abstract class. Line 7 is public instead of using default access since interfaces require public methods.
--------------------------------
But what if we want to implement both an interface and extend a class? You can't with an anonymous class, unless the class to extend is java.lang.Object.  Remember that an anonymous class is just an unnamed local class. You can write a local class and give it a name if you have this problem. Then you can extend a class and implement as many interfaces as you like.
-----------------
Permitted Modifiers	Inner class	Static nested class	Local class	Anonymous class
Access modifiers	All	           All	                    None	None
Abstract	         Yes	            Yes	                     Yes	No
Final	                 Yes	             Yes	             Yes	No
=================================
A default method is assumed to be public.
A default method cannot be marked abstract, final, or static.
If a class inherits two or more default methods with the same method signature, then the class must override the method.
=======================================================
public interface Walk {
   public default int getSpeed() { return 5; }
}

public interface Run {
   public default int getSpeed() { return 10; }
}

public class Cat implements Walk, Run {  // DOES NOT COMPILE
   public static void main(String[] args) {
      System.out.println(new Cat().getSpeed());
   }
}
BUT:
public class Cat implements Walk, Run {
   public int getSpeed() { return 1; }
 
   public static void main(String[] args) {
      System.out.println(new Cat().getSpeed());
   }
}
======================================================
Calling a Hidden default Method
public class Cat implements Walk, Run {
   public int getSpeed() { return 1; }

   public int getWalkSpeed() {
      return ___________; // TODO: Call Walk's version of getSpeed()
   }

   public static void main(String[] args) {
      System.out.println(new Cat().getWalkSpeed());
   }
}
This is an area where a default method exhibits properties of both a static and instance method. Ready for the answer? Well, first off, you definitely can't call Walk.getSpeed(). A default method is treated as part of the instance since they can be overridden, so they cannot be called like a static method.
public class Cat implements Walk, Run {
   public int getSpeed() {
      return 1;
   }

   public int getWalkSpeed() {
      return Walk.super.getSpeed();    !!! NB !!!
   }

   public static void main(String[] args) {
      System.out.println(new Cat().getWalkSpeed());
   }
}
================================
Static Interface Method Definition Rules
A static method must be marked with the static keyword and include a method body.

A static method without an access modifier is assumed to be public.

A static method cannot be marked abstract or final.

A static method is not inherited and cannot be accessed in a class implementing the interface without a reference to the interface name.
===============================
!!! NB !!! interfaces may now include private interface methods.A private interface method may be called only by default and private (non‐ static) methods within the interface definition.
=============================
public interface Swim {
   private static void breathe(String type) {
      System.out.println("Inhale");
      System.out.println("Performing stroke: " + type);
      System.out.println("Exhale");
   }
   static void butterfly()        { breathe("butterfly");  }
   public static void freestyle() { breathe("freestyle");  }
   default void backstroke()      { breathe("backstroke"); }
   private void breaststroke()    { breathe("breaststroke"); }
}
=====================
A private static interface method may be called only by other methods within the interface definition.
!!! Both private and private static methods can be called from default and private methods.. On the other hand, a private method cannot be called from a private static method.
. A key distinction, though, is that interfaces do not implement constructors and are not part of the class hierarchy. While a class can implement multiple interfaces, it can only directly extend a single class.
=============================
Declaring a Functional Interface with Object Methods
all classes inherit certain methods from Object. For the exam, you should be familiar with the following Object method declarations:
String toString()
boolean equals(Object)
int hashCode()
--------------------------------------------------------
 If a functional interface includes an abstract method with the same signature as a public method found in Object, then those methods do not count toward the single abstract method test. The motivation behind this rule is that any class that implements the interface will inherit from Object, as all classes do, and therefore always implement these methods.
Note	
Since Java assumes all classes extend from Object, you also cannot declare an interface method that is incompatible with Object. For example, declaring an abstract method int toString() in an interface would not compile since Object's version of the method returns a String.

Let's take a look at an example. Is the Soar class a functional interface?


public interface Soar {
   abstract String toString();
}
It is not. Since toString() is a public method implemented in Object, it does not count toward the single abstract method test.

On the other hand, the following implementation of Dive is a functional interface:


public interface Dive {
   String toString();
   public boolean equals(Object o);
   public abstract int hashCode();
   public void dive();
}
=============================
public interface Hibernate {
   String toString();
   public boolean equals(Hibernate o);
   public abstract int hashCode();
   public void rest();
}
Despite looking a lot like our Dive interface, the Hibernate interface uses equals(Hibernate) instead of equals(Object). Because this does not match the method signature of the equals(Object) method defined in the Object class, this interface is counted as containing two abstract methods: equals(Hibernate) and rest().
===========================
hashCode(): Any time you override equals(Object), you must override hashCode() to be consistent. This means that for any two objects, if a.equals(b) is true, then a.hashCode()==b.hashCode() must also be true. If they are not consistent, then this could lead to invalid data and side effects in hash‐based collections such as HashMap and HashSet.===================
=========================================================
any functional interface can be implemented as a lambda expression.
public interface Predicate<T> {
   boolean test(T t);
}
=================================
public class Animal {
   private String species;
   private boolean canHop;
   private boolean canSwim;
   public Animal(String speciesName, boolean hopper, boolean swimmer) {
      species = speciesName;
      canHop = hopper;
      canSwim = swimmer;
   }
   public boolean canHop()  { return canHop; }
   public boolean canSwim() { return canSwim; }
   public String toString() { return species; }
}
===================
Lambda expressions rely on the notion of deferred execution. Deferred execution means that code is specified now but runs later. In this case, later is when the print() method calls it. Even though the execution is deferred, the compiler will still validate that the code syntax is correct.
---
all correct:

() -> new Duck()
d -> {return d.quack();}
(Duck d) -> d.quack()
(Animal a, Duck d) -> d.quack()
-------------------
 we needed a lambda that returns a boolean value. Do you see what's wrong with each of these?


3: a, b -> a.startsWith("test")         // DOES NOT COMPILE
4: Duck d -> d.canQuack();              // DOES NOT COMPILE
5: a -> { a.startsWith("test"); }       // DOES NOT COMPILE
6: a -> { return a.startsWith("test") } // DOES NOT COMPILE
7: (Swan s, t) -> s.compareTo(t) != 0   // DOES NOT COMPILE
Lines 3 and 4 require parentheses around each parameter list. Remember that the parentheses are optional only when there is one parameter and it doesn't have a type declared. Line 5 is missing the return keyword, which is required since we said the lambda must return a boolean. Line 6 is missing the semicolon inside of the braces, {}. Finally, line 7 is missing the parameter type for t. If the parameter type is specified for one of the parameters, then it must be specified for all of them.
------------------------

interchangeable:
Predicate<String> p = x -> true;
Predicate<String> p = (var x) -> true;
Predicate<String> p = (String x) -> true;
---------------------------------------

public void whatAmI() {
   test((var x) -> x>2, 123);
}

public void test(Predicate<Integer> c, int num) {
   c.test(num);
}
===================================
!!! Restrictions on Using var in the Parameter List
While you can use var inside a lambda parameter list, there is a rule you need to be aware of. If var is used for one of the types in the parameter list, then it must be used for all parameters in the list. 
====================
11: public void variables(int a) {
12:    int b = 1;
13:    Predicate<Integer> p1 = a -> {
14:       int b = 0;
15:       int c = 0;
16:       return b == c;}
17: }
3 synthax errors: l.13: cant redeclare a, l.14: cant redeclare b; l.16: missing ; at the end of p1
=======================================
Lambda bodies are allowed to use static variables, instance variables, and local variables if they are final or effectively final. 
4:  public class Crow {
5:     private String color;
6:     public void caw(String name) {
7:        String volume = "loudly";
8:        color = "allowed";
9:        name = "not allowed"; // doesnt compile: not effectively final
10:       volume = "not allowed"; // same
11:       Predicate<String> p =
12:          s -> (name+volume+color).length()==9; // DOES NOT COMPILE
13:    }
14: }
In this example, the values of name and volume are assigned new values on lines 9 and 10. For this reason, the lambda expression declared on lines 11 and 12 does not compile since it references local variables that are not final or effectively final. If lines 9 and 10 were removed, then the class would compile.
================================
Instance and static variables can be marked final.

 When an enum contains only a list of values, the semicolon (;) after the list is optional. When an enum contains any other members, such as a constructor or variable, then it is required:
  public class FlavorsEnum {
           enum Flavors {
              VANILLA, CHOCOLATE, STRAWBERRY // in this case u need ;
              static final Flavors DEFAULT = STRAWBERRY;
           }
           public static void main(String[] args) {
              for(final var e : Flavors.values())
                 System.out.print(e.ordinal()+" ");
           }
        }
If the missing semicolon was added, then the program would print 0 1 2 at runtime.

The purpose of this line is to provide a default flavor for the Flavors enum. If at any point in the program you need a default or fallback value, you can reference Flavors.DEFAULT, which will always return the STRAWBERRY flavor.
==============================

  1:  public class Movie {
        2:     private int butter = 5;
        3:     private Movie() {}
        4:     protected class Popcorn {
        5:        private Popcorn() {}
        6:        public static int butter = 10; // !!! Inner classes are only allowed to contain static variables that are marked final. 
        7:        public void startMovie() {
        8:           System.out.println(butter);
        9:        }
        10:    }
        11:    public static void main(String[] args) {
        12:       var movie = new Movie();
        13:       Movie.Popcorn in = new Movie().new Popcorn();
        14:       in.startMovie();
        15:    } }
If the final modifier was added on line 6, then the code would print 10 at runtime. Note that private constructors can be used by any methods within the same class.
==============================

A default interface method can be declared private.

A default interface method can be declared public.

A default interface method can be declared static.

A private interface method can be declared abstract.

A private interface method can be declared protected.

A private interface method can be declared static.

Answer:
B, F. A default interface method is always public, whether you include the identifier or not, making option B correct and option A incorrect. Interfaces cannot contain default static methods, making option C incorrect. Option D is incorrect, as private interface methods are not inherited and cannot be marked abstract. Option E is incorrect, as a method can't be marked both protected and private. Finally, interfaces can include both private and private static methods, making option F correct.
=============================================




























































