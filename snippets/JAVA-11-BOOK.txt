=================== DATA TYPES ======================================================================================= 
the caret symbol (^) is used as the bitwise XOR (exclusive OR) operator:

Binary Representation: First, convert the integer values of apples and oranges to their binary form.
Bitwise XOR Operation: The XOR operator compares each bit of the binary representations. If the corresponding bits are different, the result is 1; if they are the same, the result is 0.

gas = gas ^ gas;
The logical XOR operator (^) is a bitwise operator in Java. However, gas is a boolean, and this line will always set gas to false because any boolean XORed with itself is always false (i.e., true ^ true is false and false ^ false is false)
__________________________________________________________________________

public void math() {
   _____ pi = 3.14;
}
byte

double

float

short

var

Answer:
byte and short do not store values with decimal points. Option C is tempting. However, 3.14 is automatically a double. It requires casting to float or writing 3.14f to be assigned to a float. Therefore, option B is correct. Additionally, option E is correct because local variable type inference is able to automatically determine the type is double.
-----------------------------------------------------------------------------------------
!= (Not equal to) has a lower precedence compared to the arithmetic and unary operators.
* (Multiplication) and / (Division) have the same level of precedence.
-- (Decrement) and ++ (Increment) have a higher precedence than arithmetic operators.
Precedence Order (from lower to higher for the given operators):

!= (relational operators)
< (relational operators)
*, /, % (multiplicative operators)
! (logical NOT, unary operator)
--, ++ (unary operators, increment/decrement)
compound addition operator (+=) and short‐circuit logical operator (&&) have a lower precedence than the not equals operator (!=)
------------------------------------------------------------------------------------------------------------------------
Comparator is an interface used to define custom orderings.
You can implement Comparator using anonymous classes, lambda expressions, or method references.
The var keyword can be used in lambda expressions to infer parameter types, but you must use var consistently for all parameters in the lambda expression.
public static void main(String[] args) {
        List<String> strings = Arrays.asList("apple", "banana", "cherry", "date");
        Comparator<String> lengthComparatorLambda = (s1, s2) -> Integer.compare(s1.length(), s2.length());
        strings.sort(lengthComparatorLambda); // can replace with Collections
        System.out.println(strings); // Output: [date, apple, banana, cherry]
    }
----------------------------------------------------------------------------------------
The charAt() and length() methods are declared on both String and StringBuilder. However, the insert() method is declared only on a StringBuilder and not a String.
----------------------------------------------------------------------------------------
Which of the following declarations does not compile?

A. double num1, int num2 = 0;

int num1, num2;

int num1, num2 = 0;

int num1 = 0, num2 = 0;


Answer:
A.   Option A does not compile because Java does not allow declaring different types as part of the same declaration. The other three options show various legal combinations of combining multiple variables in the same declarations with optional default values.
-------------------------------------------------------------------------------------
Which is one of the lines output by this code?


10: var list = new ArrayList<Integer>();
11: list.add(10);
12: list.add(9);
13: list.add(8);
14:
15: var num = 9;
16: list.removeIf(x -> {int keep = num; return x != keep;});
17: System.out.println(list);
18:
19: list.removeIf(x -> {int keep = num; return x == keep;});
20: System.out.println(list);
[]

[8, 10]

[8, 9, 10]

[10, 8]

The code does not compile.

Answer:
A.   The code starts by creating a list of three elements. On line 16, it removes two elements and then removes the final one on line 19. This prints an empty list, making option A the correct answer. Note that num is effectively final, so can be used in a lambda.
--------------------------------------------------------------------------------------------
How many of the following lines contain a compiler error?


double num1 = 2.718;
double num2 = 2._718;
double num3 = 2.7_1_8;
double num4 = _2.718;
0

1

2

3

4

Answer:
C.   Underscores are allowed between any two digits in a numeric literal, causing num4 to fail to compile. Additionally, underscores are not allowed adjacent to a decimal point, causing a compiler error in num2.
--------------------------------------------------------------------------------------------
In Java, underscores (_) can be used to make numeric literals more readable, especially when dealing with large numbers. This feature was introduced in Java 7. Here are some rules and examples:

Between Digits: You can place underscores between digits in a numeric literal to group digits for better readability.

java
Copy code
int thousand = 1_000;
long creditCardNumber = 1234_5678_9012_3456L;
float pi = 3.14_15F;
double exp = 1.6e1_0;

double num1 = 1_000.123_456;  // Valid use of underscores
int hex = 0xFF_EC_DE_5E;      // Valid use in a hexadecimal literal
long bin = 0b1101_0101_0011;  // Valid use in a binary literal

double num2 = 2._718;         // Invalid: underscore adjacent to decimal point
double num3 = _2.718;         // Invalid: underscore at the beginning
double num4 = 2.718_;         // Invalid: underscore at the end
double num5 = 2.718_d;        // Invalid: underscore before suffix
int num6 = 100_;              // Invalid: underscore at the end
The double type in Java represents 64-bit floating-point numbers.
Underscores in numeric literals improve readability and are allowed between digits.
Underscores are not allowed at the beginning, end, adjacent to a decimal point, or before suffixes.
====================
Difference Between double and float in Java
Precision and Size
Precision:

float: Single-precision 32-bit IEEE 754 floating point.
Precision: Approximately 6-7 decimal digits.
double: Double-precision 64-bit IEEE 754 floating point.
Precision: Approximately 15-17 decimal digits.
Size:

float: 32 bits (4 bytes).
double: 64 bits (8 bytes).
Range
Range:
float: Approximately ±1.4E-45 to ±3.4E38.
double: Approximately ±4.9E-324 to ±1.7E308.
Syntax
Syntax:
float: Requires a suffix f or F to indicate that the number is a float.
java
Copy code
float num = 3.14f;  // or 3.14F
double: Default type for floating-point literals, no suffix needed. A suffix d or D can be used, but it is optional.
java
Copy code
double num = 3.14;  // or 3.14d or 3.14D
Performance
Performance:
float: Uses less memory and can be faster on systems where memory bandwidth is limited.
double: More precise but can be slower due to the increased size and complexity of the calculations.
Use Cases
Use Cases:
float:
When memory savings are crucial.
For large arrays of floating-point numbers.
When precision requirements are lower (e.g., graphical calculations, simple simulations).
double:
When higher precision is needed (e.g., scientific calculations, financial calculations).
Default choice for floating-point calculations due to its precision.
Choosing Between float and double
When to use float:

If you are working with a large array of floating-point numbers and memory is a concern.
When precision requirements are not very strict (e.g., graphics, simple game physics).
In environments with limited computational power or where performance is critical.
When to use double:

For most general-purpose floating-point calculations.
When dealing with scientific computations, complex mathematical operations, or financial calculations where precision is important.
If the size of data is not a major concern compared to the need for precision.
Examples
Using float:

java
Copy code
public class FloatExample {
    public static void main(String[] args) {
        float num1 = 3.14f;
        float num2 = 1.2345678f;  // Precision limited to 7 digits
        System.out.println("Float values: " + num1 + ", " + num2);
    }
}
Using double:

java
Copy code
public class DoubleExample {
    public static void main(String[] args) {
        double num1 = 3.14;
        double num2 = 1.2345678901234567;  // Precision up to 15-17 digits
        System.out.println("Double values: " + num1 + ", " + num2);
    }
}
Summary
float is a 32-bit single-precision floating point.
double is a 64-bit double-precision floating point.
Use float for memory-sensitive applications with less precision requirement.
Use double for general-purpose calculations requiring higher precision.
================================
Explanation of StringBuilder.insert() Method in Java
The StringBuilder class in Java is used to create mutable sequences of characters. It provides several methods to manipulate strings, one of which is the insert() method. This method inserts a specified string or character sequence into the StringBuilder at a specified index.

Syntax
java
Copy code
StringBuilder insert(int offset, String str)
offset: The index at which the specified string is to be inserted.
str: The string to be inserted.
=============================================================================
int time = 9;
int day = 3;
var dinner = ++time>= 10 ? day-- <= 2
   ? "Takeout" : "Salad" : "Leftovers";
Takeout

Leftovers

Salad

The code does not compile but would compile if parentheses were added.

None of the above.

Answer:
C.   While parentheses are recommended for ternary operations, especially embedded ones, they are not required, so option D is incorrect. The first expression evaluates to 10 >= 10, so the first branch of the ternary operation is selected, and "Leftovers" can be eliminated. The expression in the second ternary operation evaluates to 3 <= 2, which is false, so "Salad" is selected
==========================================================================================
What is the output of the following?


var teams = new String("694");
teams.concat(" 1155");
teams.concat(" 2265");
teams.concat(" 2869");
System.out.println(teams);
694

694 1155 2265 2869

The code compiles but outputs something else.

The code does not compile.

Answer:
A.   Since String is immutable, each call to concat() returns a new object with the new value. However, that return value is ignored, and the teams variable never changes in value. Therefore, it stays as 694, and option A is correct.
=========================================================================================

How many of the following lines compile?


bool b = null;
Bool bl = null;
int i = null;
Integer in = null;
String s = null;
None

One

Two

Three

Four

Five

Answer:
C.   First, bool and Bool are not valid Java types. They should be boolean and Boolean, respectively. Next, objects are allowed to have a null reference while primitives cannot. Since Integer and String are objects, those lines compile. Finally, the line with int is a primitive, so assigning null to it does not compile. Therefore, option C is correct.
====================================================================================
bitwise operators java:
^ - XOR Operator (^): The XOR operator returns true if the operands are different, and false if they are the same.
| - OR
& - AND
=========================
| logical OR: Bitwise OR Evaluation:
The expression becomes true | false.
The bitwise OR operator | evaluates both operands and results in true since at least one operand is true.


carrot = carrot & potato;
The & operator is the bitwise AND operator.
Since potato is a Boolean object, it will be unboxed to its primitive boolean value, which is false.
The expression carrot & potato translates to true & false, which evaluates to false.
So, carrot is updated to false.

==================================================
What does this code output?


var babies = Arrays.asList("chick", "cygnet", "duckling");
babies.replaceAll(x -> { var newValue = "baby";
   return newValue; });
System.out.println(babies);
[baby]

[baby, baby, baby]

[chick, cygnet, duckling]

None of the above.

The code does not compile.

Answer:
B.   The code successfully defines a local variable inside the lambda. Each value is replaced with baby. Since we have a List, all three are output, and option B is the correct answer.
==============================================

What is the output of the following class?


1: package rocket;
2: public class Countdown {
3:    public static void main(String[] args) {
4:       var builder = new StringBuilder("54321");
5:       builder.substring(2);
6:       System.out.println(builder.charAt(1));
7:    }
8: }
1

2

3

4

Does not compile

Answer:
D.   Line 4 creates a StringBuilder of length 5. Pay attention to the substring() method in StringBuilder. It returns a String with the value 321. It does not change the StringBuilder itself. Then line 6 retrieves the second indexed element from that unchanged value, which is 4. Therefore, option D is correct.
=============================================================
Variables declared as which of the following are never permitted in a switch statement? (Choose two.)

var

double

int

String

char

Object

Answer:
B,F.   A switch statement supports the primitive types byte, short, char, and int and the wrapper classes Character, Byte, Short, and Integer. It also supports String and enumerated types. Finally, it permits var if it can be resolved to one of the previous types. Floating‐point types like float and double are not supported; therefore, option B is correct. Object is also not supported since it could include any class, making option F correct as well.
===================================================================================
CHAPTER 2, OCP 11 
=============================================================
Which of the following rules about a default branch in a switch statement are correct? (Choose two.)

A switch statement is required to declare a default statement.

A default statement must be placed after all case statements.

A default statement can be placed between any case statements.

Unlike a case statement, a default statement does not take a parameter value.

A switch statement can contain more than one default statement.

A default statement can be used only when at least one case statement is present.

Answer:
C,D.   A default statement inside a switch statement is optional and can be placed in any order within the switch's case statements, making options A and B incorrect and option C correct. Option D is also correct because a default statement does not take a parameter value. Options E and F are incorrect rules about switch statements.----------------
--------------------------------------------------------------------------------
What does the following method output?


void dance() {
   var singer = 0;
   while (singer)
      System.out.print(singer++);
}
The code does not compile.

The method completes with no output.

The method prints 0 and then terminates.

The method enters an infinite loop.

None of the above.

Answer:
A.   A while loop requires a boolean condition. While singer is a variable, it is not a boolean. Therefore, the code does not compile, and option A is correct.
-----------------------------------------------------
What is the result of executing the following code snippet?


final var GOOD = 100;
var score = 10;
switch (score) {
   default:
   1 : System.out.print("1-");
   -1 : System.out.print("2-"); break;
   4,5 : System.out.print("3-");
   6 : System.out.print("4-");
   9 : System.out.print("5-");
}
1‐

1‐2‐

2‐

3‐

4‐

None of the above

Answer:
F.   The code does not compile because the switch statement is missing the case keyword for each value. Also, two case values cannot be combined as in 4,5.
-----------------------------------------------------------------------------------------------------------------------------------------
What variable type of red allows the following application to compile?


package tornado;
public class Kansas {
   public static void main(String[] args) {
      int colorOfRainbow = 10;
      ___________ red = 5;
      switch(colorOfRainbow) {
         default:
            System.out.print("Home");
            break;
         case red:
            System.out.print("Away");
      }
   }
}
long

double

int

var

String

None of the above

Answer:
F.   The value of a case statement must be a constant, a literal value, or a final variable. Since red is missing the final attribute, no variable type allows the code to compile, making option F the correct answer. If the final modifier was added to the declaration of red, then int or var would be correct. The other options use types that are incompatible with switch statements or with colorOfRainbow.
----------------------------------------------------------------
How many lines of the magic() method contain compilation errors?


10: public void magic() {
11:    do {
12:       int trick = 0;
13:       LOOP: do {
14:          trick++;
15:       } while (trick < 2--);
16:       continue LOOP;
17:    } while (1> 2);
18:    System.out.println(trick);
19: }
Zero

One

Two

Three

Four

Answer:
D.   Line 15 does not compile because the post‐decrement operator can be applied only to variables, not values. Line 16 also does not compile because the label LOOP is out of scope after line 15. Finally, line 18 does not compile because trick is declared within the do/while loop and out of scope after line 17. For these reasons, option D is the correct answer.
---------------------------------------------------------------------


while (singer)
In Java, the while loop condition expects a boolean expression. Here, singer is an int, not a boolean.
Unlike C or C++, Java does not implicitly convert integers to boolean values. Therefore, using an integer directly in a condition is a compilation error.
--------------------------------------------------------------------------------


plan = 1 (result of plan++) + 1 (result of --plan);
plan = 2;
Execution Summary:
Initial value of plan: 1
During evaluation:
plan++ returns 1 and plan becomes 2.
--plan decrements plan (which is 2) back to 1 and returns 1.
-------------------------------------------------------------------------------------------------

A List in Java is an ordered collection (also known as a sequence). The main characteristics of a List are:

It can contain duplicate elements.
It maintains the order of insertion.
Elements can be accessed by their index.
Java provides various implementations of the List interface, such as ArrayList, LinkedList, Vector, and Stack.
List<String> list = new ArrayList<>();
list.add("glass");
list.add("plastic");
list.add("can");
Using List.of (Java 9+):

java
Copy code
List<String> list = List.of("glass", "plastic", "can");
Accessing Elements in a List
You can access elements in a List using the get method with an index:

java
Copy code
String element = list.get(0); // Accesses the first element, "glass"
Iterating Over a List
You can iterate over a List using various methods:

Using a for loop:

java
Copy code
for (int i = 0; i < list.size(); i++) {
    System.out.println(list.get(i));
}

------------------------------------------------------------------------------------------------------------------


The value of a case statement must be a constant, a literal value, or a final variable. !!!!!!!!!!!!!!!!!!!!!!!!!!!!
-------------------------------------------------------------------------------

} while (trick < 2--);
This line contains a compilation error:
The expression 2-- is invalid. The decrement operator -- cannot be applied to a constant literal.
--------------------------------------------------------------------------------------------

break;
break letters;
break numbers;
continue;
continue letters;
continue numbers;

letters: for (char ch = 'a'; ch <= 'z'ch++ {
   numbers: for (int n=0; n <= 10; n++ {
	System.out.print(ch);
// from here exit and go back to letters loop
   }
}

One

Two

Three

Four

Five

None of above

Answer:
C.   If the code follows the arrow, then it prints each letter once, breaking out of the inner loop on every iteration. Since a break without a label applies to the innermost structure, break and break numbers are equivalent, and both of these are correct answers. Likewise, continue and continue numbers are both equivalent although both wrong in this case since they resume operation of the inner loop. That leaves break letters and continue letters. In this case, break letters stops the outer loop after printing just one letter, so it is incorrect. On the other hand, continue letters exits the inner loop and returns control to the outer loop, which is the desired behavior. Since three statements are correct, option C is correct.
----------------------------------------------------------------------------------------------


Which of the following statements compile and create infinite loops at runtime? (Choose two.)

while (!false) {}

do {}

for( : ) {}

do {} while (true);

while {}

for( ; ; ) {}

Answer:
A,D,F.   A while loop and do/while loop both require a boolean expression, making options A and D correct and options B and E incorrect. Option C is incorrect because a for‐each statement requires an assignment type and an object to iterate on. Option F is correct and shows a traditional for loop with no arguments.
---------------------------------------------------------------------------------
int k=0; do { } while(k++ < 5);

int k=0; while (k++ < 5) {}

All of these iterate the same number of times.

Answer:
C.   Option A goes through five indexes on the iterations: 0, 1, 2, 3, and 4. Option B also goes through five indexes: 1, 2, 3, 4, and 5. Option D goes through five iterations as well, from 0 to 4. However, option C goes through six iterations since the loop condition is at the end of the loop. Therefore, it is not like the others, and option C is the correct answer
--------------------------------------------------------------------------------------------------
The statement if(jumps) evaluates to if(0), and since 0 is not a boolean value, the code does not compile. Java requires boolean expressions in if statements.
--------------------------------------------------------------


Which of the following best describes the flow of execution in this for loop if beta always returns false?


for (alpha; beta; gamma) {
  delta;
}
alpha

alpha, beta

alpha, beta, gamma

alpha, gamma

alpha, gamma, beta

None of the above

Answer:
B.   The initializer, which is alpha, runs first. Then Java checks the condition, which is beta, to see whether loop execution should start. Since beta returns false, the loop is never entered, and option B is correct.
---------------------------------------------------------------------------


The expression if (!balloonInflated) means that the code inside the if block will execute if the variable balloonInflated is false.

-----------------------------------------------------------------------------------------

A do/while loop requires a body.
--------------------------------------------------------------------------------------

Fill in the blank with the line of code that causes the application to compile and print exactly one line at runtime.


package nyc;
public class TourBus {
   public static void main(String... args) {
      var nycTour = new String[] { "Downtown", "Uptown",
         "Brooklyn" };
      var times = new String[] { "Day", "Night" };
      for (_______________ i<nycTour.length && j<times.length;
            i++, j++)
         System.out.println(nycTour[i] + "-" + times[j]);
   }
}
int i=1; j=1;

int i=0, j=1;

int i=1; int j=0;

int i=1, int j=0;

int i=1, j=0;

None of the above

Answer:
B.   In a traditional for loop, only one initialization type is allowed to be specified. If more than one variable is supplied, then they are separated by a comma.
--------------------------------------------------------------------------------------


 a switch statement needs braces regardless of how many case statements are inside.
---------------------------------------------------------------------------------

public static void main(String[] args) {
13:    int secret = 0;
14:    for (int i = 0; i < 10; i++) {
15:       while (i < 10) {
16:          if (i == 5) {
17:             System.out.println("if");
18:          } else {
19:             System.out.println("in");
20:             System.out.println("else");
21:          }
22:       }
23:    }
24:    switch (secret) {
25:       case 0:  System.out.println("zero");
26:    }
27: }
One

Two

Three

Four

Five

Six

Answer:
C.   The braces on lines 12/27 are required because they comprise the method body. The braces on lines 24/26 are required because a switch statement needs braces regardless of how many case statements are inside. Finally, the braces on lines 18/21 are required because the else has two statements inside.

The braces on lines 14/23, 15/22, and 16/18 are all optional because there is only one statement inside. Since there are three pairs, option C is correct.
---------------------------------------------------------------------------------------


=============== OBJECTS ==================================
Objects are created using the new keyword, which allocates memory for the object on the heap.
MyClass obj = new MyClass();

When an object reference is reassigned, the previous object it referenced becomes dereferenced if no other references exist.
MyClass obj = new MyClass();
obj = new MyClass(); // The first object is now dereferenced.

The Java garbage collector automatically reclaims memory from dereferenced objects. This process is non-deterministic and managed by the JVM.
obj = null; // Explicitly dereference the object (optional)
System.gc(); // Request garbage collection (not guaranteed)


A class can start with a comment, an optional package statement, or an import statement if there is no package statement. It cannot start with a variable definition or method declaration, since those cannot be declared outside a type


An abstract method in Java is a method that is declared without an implementation. It serves as a blueprint for subclasses to provide the actual implementation. Here are the rules regarding the modifiers that can be applied to an abstract method:

An abstract method cannot include the final or private modifier. If a method contained either of these modifiers, then no concrete subclass would ever be able to override it with an implementation. For these reasons, options A and B are incorrect. Option D is also incorrect because the default keyword applies to concrete interface methods, not abstract methods.

1: public class ParkRanger {
2:    int birds = 10;
3:    public static void main(String[] data) {
4:       var trees = 5;
5:       System.out.print(trees+birds);
6:    }
7: }

The code does not compile because of line 5. The main() method is static and does not have access to any class instance variables. The birds variable is not static and requires a class instance variable to access. Therefore, the code does not compile when the static method attempts to access a non‐static variable without an instance of the class.

The public access modifier allows access to members in the same class, package, subclass, or even classes in other packages, while the private modifier allows access only to members in the same class. Therefore, the public access modifier allows access to everything the private access modifier does, and more

There is no modifier that can prevent a default method from being overridden in a class implementing an interface


public class Dinosaur {
   class Pterodactyl extends Dinosaur {}
   public void roar() {
      var dino = new Dinosaur();
      ___________________;
   }
}
dino.new Pterodactyl()
new Dinosaur.Pterodactyl()

ce. Interfaces support static methods that are marked public or private, making options B and D correct and option E incorrect. Option F is correct and lack of access modifier makes the method implicitly public, not package‐private, making option C incorrect.

Fill in the blanks with the only option that makes this statement false: A(n) ______________ can access ______________ of the enclosing class in which it is defined.

static nested class, static members

static nested class, instance members

member inner class, static members

member inner class, instance members

local class, instance members from within an instance method

anonymous class, instance members from within an instance method

Answer:
B.   A static nested class cannot access instance members of the enclosing class, making option B correct. The rest of the options form true statements.



Effectively final is a concept in Java where a local variable is not explicitly declared as final but is never modified after its initial assignment. This means that the variable could be made final without any changes to the code, as it meets all the requirements of a final variable.This property allows the variable to be used in lambda expressions and anonymous classes, which require variables to be final or effectively final.


The this keyword can be used to read all members declared within the class.

The super keyword can be used to read all members declared in a parent class. // not if private, only inhereted!

The this keyword can be used to read public members in the direct parent class.
this can access all members declared within the class. Option C is incorrect, as only inherited members can be accessed. For example, private members declared in a parent class cannot be accessed using super. Option E is correct, as this allows access to members declared in the class and those inherited from a parent. Finally, option F is incorrect, as static methods do not have access to this or super references.

A class can implement an interface, not extend it. Classes do extend an abstract class, &&&________an interface can only extend another interface______________&&&

The String... x parameter in the talk method allows the method to accept zero or more String arguments.
Internally, the varargs parameter is treated as an array of the specified type (String[] in this case).

NB!! Java does not allow multiple inheritance, so having one class implement two interfaces that both define the same default method signature leads to a compiler error, unless the class overrides the method. In this case, the talk(String…) method defined in the Performance class is an overloaded method, not an overridden one, because the signatures do not match. %%%%%%%%%%%%%%%%%


interface Pump {
   void pump(double psi);
}
interface Bend extends Pump {
   void bend(double tensileStrength);
}
public class Robot {
   public static final void apply(
      Bend instruction, double input) {
      instruction.bend(input);
   }
   public static void main(String... future) {
      final Robot r = new Robot();
      r.apply(x -> System.out.print(x+" bent!"), 5);
   }
}
5 bent!

5.0 bent!

The code does not compile because Bend is not a functional interface.

The code does not compile because of the apply() method declaration.

None of the above.

Answer:
C.   A functional interface must contain exactly one abstract method. The Bend interface contains two abstract methods, pump() and bend(), since it extends Pump and inherits pump(). For this reason, the Bend interface is not a valid functional interface and therefore cannot be used as a lambda expression, making option C the correct answer. The rest of the code compiles without issue. Note that the usage of an instance variable to call a static method, r.apply() in the main() method, is permitted but discouraged.

Which statement is true about encapsulation while providing the broadest access allowed?
Variables are private, and methods are public.


Package‐private allows access by code within the same package, while the private modifier allows access only to members in the same class. 

In Java, package-private is an access level that is the default when no other access modifier is specified. It means that the member (class, method, or variable) is accessible only within its own package. This level of access is also known as "default access."

n Java, interfaces are a way to define a contract that classes can implement. Interfaces can contain abstract methods, default methods, static methods, constants (usually static final fields), and private methods (since Java 9)
Interfaces can declare constants. By default, these are public, static, and final.
String DEFAULT = "Diving!"; // Constant (public, static, final by default)
Static Methods:

========================================================================================================================
Interfaces can have static methods. These methods have a body and can be called on the interface itself, not on instances of the implementing classes.

static String dive() {
   return DEFAULT; // Static method
}
Default Methods:

Interfaces can have default methods. These methods have a body and provide a default implementation. They can be overridden by implementing classes.
default void swim() {
   System.out.println("Swimming");
}
Private Methods (Java 9 and later):

Interfaces can have private methods. These methods are used to share code between default methods and static methods.
private static void helper() {
   // private method
}

 Methods cannot be both abstract and final, Abstract interface methods are always public,interface and void are not modifiers on a method

// Define the interface with abstract methods
public interface Animal {
    void eat(); // Abstract method (implicitly public and abstract)
    void sleep(); // Abstract method (implicitly public and abstract)
}

 An instance variable can be referenced only from instance methods in the class, making option A correct. A static variable can be referenced from any method.


=====================================================================================================================================
an enum cannot be defined in a non‐static inner class. Only top‐level types and static nested classes can define static members other than static constants, and enums are implicitly static.
========================================================================================================================================================================

While an anonymous class can extend another class or implement an interface, it cannot be declared final or abstract since it has no class definition. 
============================================================================================================================================================
var hot = 100, var cold = 20;  // line x2
var f = 32, int c = 0;         // line x3
 Java does not allow multiple variables to be declared in the same statement using local variable type inference. Lines x2 and x3 both have compiler errors.

Only private and private static interface methods are not public, and they must be explicitly marked private.

From within a method, an array or varargs parameter is treated the same. However, there is a difference from the caller's point of view. A varargs parameter can receive either an array or individual values, However, an array parameter can take only an array, null can be passed to a method taking an array or a varargs.

Which of the following can include a static method in its definition? (Choose three.)

Interface

Anonymous class

Abstract class

Member inner class

Local class

static nested class

Answer:
A,C,F.   Both abstract classes and interfaces can include static methods, so options A and C are correct. Of all the nested class types, only static nested classes can include static methods, making option F correct, and options B, D, and E incorrect.
========================================================================================================================================================================================
A functional interface in Java is an interface that contains exactly one abstract method. This single abstract method represents the contract of the interface. Functional interfaces can have multiple default and static methods, but only one abstract method. They are the foundation of lambda expressions and method references in Java.
@FunctionalInterface Annotation
Java provides the @FunctionalInterface annotation, which is used to declare an interface as a functional interface. It is not mandatory to use this annotation, but it helps to prevent accidental addition of abstract methods in the interface.

@FunctionalInterface
public interface Play {
   public static void baseball() {}
   private static void soccer() {}
   default void play() {}
   void fun();
}

This code is already a functional interface and compiles without any changes. The Play interface has a single abstract method: fun(). The other methods have a method body, which shows they are not abstract.

UnaryOperator<T>: Represents an operation on a single operand that produces a result of the same type as its operand.

@FunctionalInterface
public interface UnaryOperator<T> extends Function<T, T> {}
BinaryOperator<T>: Represents an operation upon two operands of the same type, producing a result of the same type as the operands.
@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T, T, T> {}

Functional Interface: An interface with exactly one abstract method.
@FunctionalInterface: Annotation to declare a functional interface.
Lambda Expressions: Provide a concise way to implement the single abstract method of a functional interface.
Method References: Another way to implement functional interfaces using existing method implementations.
Common Functional Interfaces: Predicate, Function, Consumer, Supplier, UnaryOperator, BinaryOperator.
==========================================================================================================================================================================================


--- METHOD HIDIDNG ---
Variable hiding occurs when a subclass declares an instance variable with the same name as one in its superclass. This hides the superclass's variable within the subclass.

class Parent {
    int x = 10;
}

class Child extends Parent {
    int x = 20;
    
    void printX() {
        System.out.println("Child x: " + x); // refers to Child's x
        System.out.println("Parent x: " + super.x); // refers to Parent's x
    }
}

== NB ==

class Parent {
    static void staticMethod() {
        System.out.println("Parent static method");
    }
}

class Child extends Parent {
    static void staticMethod() {
        System.out.println("Child static method");
    }
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Child();
        p.staticMethod(); // Calls Parent's static method
        Child.staticMethod(); // Calls Child's static method
    }
}

=== END NB ===

Variable Hiding: Occurs when a subclass defines an instance variable with the same name as a variable in the parent class. The parent class variable can be accessed using the super keyword.
Method Hiding: Occurs when a subclass defines a static method with the same signature as a static method in the parent class. The method invoked is determined by the reference type.
Method Overriding: Occurs when a subclass provides a specific implementation for an instance method defined in the parent class. The method invoked is determined by the object type.
---------------------------------------------------------------------------------------------------------------------------------

== NB ==
The instance variables, constructor, instance and static initializers, and method declarations can appear in any order within a class declaration.

Which of the following is not a valid order for elements within a class?

Constructor, instance variables, method declarations

Instance variables, static initializer constructor, method declarations

Method declarations, instance variables, constructor

Instance initializer, constructor, instance variables, constructor

None of the above
-------------------------------------------------------------------------------------

Remember that the default initialization of a boolean instance variable is false
// aka: protected boolean outside; is actually init to false
----------------------------------------------------------------------------------------

 === NB ===
Constructor chaining refers to calling one constructor from another using the this keyword. It helps in avoiding duplicate code and better managing constructor logic.

Inside the default constructor:
new Jump(4); creates a new temporary Jump instance with rope set to 5 (since outside is initially false).
This new instance is discarded after the constructor call.
-----------------------------------------------------------------------

Which of the following is not a reason to use encapsulation when designing a class? (Choose two.)

C. Maintain class data integrity of data elements.

D. Prevent users from modifying the internal attributes of a class.

E. Prevent variable state from changing.

F. Promote usability by other developers.

Answer:
B, E. Implementing encapsulation prevents internal attributes of a class from being modified directly, so option D is a true statement. By preventing access to internal attributes, we can also maintain class data integrity between elements, making option C a true statement. Option F is also a true statement about encapsulation, since well‐encapsulated classes are often easier to use. Option B is an incorrect statement. Encapsulation makes no guarantees about performance and concurrency. Option E is also an incorrect statement because it describes immutability.
-----------------------------------------------------------------------------------

================ NB ===========================
Line u4 also does not compile because class SwingDancer is marked abstract and cannot be instantiated directly.
----------------------------

 === NB ====
Option A is allowed because the turnOn() method is public and can be called from anywhere. Options B and D are allowed since the method is in the same class, which is always allowed! Option C is not allowed because wash() is a package‐private method in another package.

============ NB ==================================================================
Here's a quick overview of access levels in Java:

public: The member is accessible from any other class.
protected: The member is accessible within its own package and by subclasses.
default (package-private): If no access modifier is specified, the member is accessible only within its own package.
private: The member is accessible only within its own class
=====================================================================
  == NB ===
In Java, the concept of inheritance is restricted in several ways to maintain simplicity and avoid the complexity of multiple inheritance issues found in other languages like C++. Here's a summary of the correct statements about inheritance in Java:

Multiple Inheritance with Classes:

Java does not allow multiple inheritance with classes.
A class can only extend one superclass.
Multiple Inheritance with Interfaces:

Java allows multiple inheritance using interfaces.
A class can implement multiple interfaces.
Interface Inheritance:

An interface can extend another interface.
This allows for the creation of more complex interface hierarchies.
Incorrect Concept:

An interface cannot implement another interface.
Interfaces can only extend other interfaces, not implement them.
-------------------------------------------------------------------------------

============ NB ===================
default int getSize() { ... }
The keyword default can only be used in the context of interface methods in Java, not in class methods. This line causes a syntax error.
------------------------------------
abstract interface: The abstract keyword is redundant here because interfaces are implicitly abstract. It can be omitted.
----------------------------------------------------------------
Final Classes: Cannot be subclassed.
-------------------------------------------------------------

An anonymous class in Java is a class without a name that is defined and instantiated in a single expression. They are often used to implement interfaces or extend classes in a concise manner.

CanSwim seaTurtle = new CanSwim() {
    @Override
    public void swim(final int distance) {
        System.out.print(distance);
    }
};
=================================================================================

============= NB =================================
 The Puppy class does not declare a constructor, so the default no‐argument constructor is automatically inserted by the compiler. What looks like a constructor in the class is actually a method that has a return type of void. Therefore, the line in the main() method to create the new Puppy(2) object does not compile, since there is no constructor capable of taking an int value, making option E the correct answer.
-----------------------------------------------------------------------------------

============= NB ===========================================
When interfaces contain default methods, a class implementing those interfaces may need to resolve conflicts.
THE DIAMOND PROBLEM:
Occurs when a class inherits the same method from multiple interfaces.
Java requires explicit resolution when method signatures conflict.

To resolve the conflict from multiple default methods with the same name but different return types, Tower class(which implements both interfaces) must explicitly provide an implementation of the getHeight method.

interface Building {
    default Double getHeight() { return 1.0; } // m1
}

interface Office {
    public default String getHeight() { return null; } // m2
}

abstract class Tower implements Building, Office { // m3
    @Override
    public Double getHeight() {
        return Building.super.getHeight();
    }
}

public class Restaurant extends Tower {} // m4
Default Methods: Allow interfaces to provide method implementations.
Multiple Inheritance: Java allows implementing multiple interfaces, but conflicts must be resolved explicitly.
Conflict Resolution: When default methods with the same name but different return types exist in different interfaces, an implementing class must provide an explicit method implementation to resolve the conflict.
----------------------------------------------------------------------------------------

========= NB ==========
The abstract method does not have a body and must be implemented by subclasses. Abstract methods can only be declared in abstract classes.
-------------------------------------------------------------------
== NB ==
 private and final: A method can be both private and final. This means the method is not accessible outside its own class and cannot be overridden by subclasses.
#####

A method can be both static and private. This means the method belongs to the class and is not accessible outside its own class.
#####

An abstract method must be implemented by subclasses, which cannot happen if the method is private since private methods are not accessible outside their own class.
####

An abstract method must be instance-specific and implemented by subclasses, while a static method belongs to the class itself and cannot be overridden.
####

A method can be both static and protected. This means the method belongs to the class and is accessible within its own package and by subclasses.

--> ABSTRACT CLASS CANT BE private, final or static
------------------------------------------------------------------------

A final instance must be assigned a value (exactly once) on the line it is declared, in an instance initializer, or in a constructor. This makes options A, D, and E correct.
--------------------------------------------------------------------------------

What is the output of the following code?


public class Bunny {
   static interface Rabbit { }
   static class FlemishRabbit implements Rabbit { }

   private static void hop(Rabbit r) {
      System.out.print("hop");
   }
   private static void hop(FlemishRabbit r) {
      System.out.print("HOP");
   }
   public static void main(String[] args) {
      Rabbit r1 = new FlemishRabbit();
      FlemishRabbit r2 = new FlemishRabbit();
      hop(r1);
      hop(r2);
   }
}
hophop

HOPhop

hopHOP

HOPHOP

The code does not compile.

Answer:
C.   This example deals with method signatures rather than polymorphism. Since the hop() methods are static, the precise method called depends on the reference type rather than the actual type of the object. Since the first reference is Rabbit, the first value printed is hop. The second reference actually is FlemishRabbit, so HOP is printed, and option C is the answer.
-----------------------------------------------------------------------------------------------------------------------------------------------------

============= NB ===================
A class cannot contain two methods with the same method signature, even if one is static and the other is not. Therefore, the code does not compile
------------------------------------------------------------------------------------------------------------


 **** overriding a method **************

The return types must be covariant.

Correct. Covariant return types allow the overriding method in the subclass to return a more specific type (a subtype) than the return type of the overridden method in the superclass.
The access modifier of the method in the child class must be the same or narrower than the method in the superclass.

Incorrect. The access modifier of the overriding method in the subclass must be the same or broader (more accessible) than the method in the superclass, not narrower.
The return types must be the same.

Incorrect. The return types do not have to be exactly the same; they must be covariant. This means the return type in the subclass can be a subtype of the return type in the superclass.
A checked exception thrown by the method in the parent class must be thrown by the method in the child class.

Incorrect. The subclass method does not have to throw the same checked exception. It can throw a subset of the checked exceptions thrown by the superclass method or no exception at all.
A checked exception thrown by a method in the child class must be the same or narrower than the exception thrown by the method in the parent class.

Correct. If the subclass method throws a checked exception, it must be the same or a subtype (narrower) of the exception thrown by the superclass method.
The access modifier of the method in the child class must be the same or broader than the method in the superclass.

Correct. The access modifier of the overriding method in the subclass must be the same as or broader (more accessible) than the method in the superclass to ensure that the subclass method is at least as accessible as the superclass method.
---------------------------------------------------------------------------------------------------------------

Line 12: The happy() method, which is a default method, tries to call printFlavor(). Since printFlavor() is a private instance method, it can be called from within the default method of the same interface. This line compiles.

Line 15: The excited() method, which is a private static method, tries to call printFlavor(). This line does not compile because printFlavor() is not a static method and cannot be called from a static context. This line does not compile.

Line 21: The sad() method, which is a public static method, tries to call printFlavor(). This line does not compile because printFlavor() is not a static method and cannot be called from a static context. This line does not compile.

Line 26: The happy() method in the IceCream class, which overrides the happy() method in the Flavor interface, tries to call printFlavor(). Since printFlavor() is a private method in the interface, it is not inherited by the implementing class, and thus cannot be called directly. This line does not compile.

======================== NB =====================================
 interfaces in Java can have private methods. Private methods in interfaces are used to share common code between default and static methods within the interface itself. These methods cannot be accessed outside the interface.
================== mNB ===============================================
interface variables are implicitly given the following modifiers: public, static, and final. The one modifier from the list that is not implicitly applied to interface variables is abstract.
-------------------------------------------------------------------------------------
Integer is the name of a class in Java. While it is bad practice to use the name of a class as your local variable name, this is legal. Therefore, k1 does compile. It is not legal to use a reserved word as a variable name. All of the primitives including int are reserved words.---------
-----------------------------------------------------------------------------------

bility to understand variable scope. The variable today has local scope to the method in which it is executed. The variable tomorrow is re‐declared in the method, but the reference used on line y is to the instance variable with a value of 10. Finally, the variable yesterday is static. 
!!!!!!!!!!!!! -> While using an instance reference to access a static variable is not recommended, it does not prevent the variable from being read.
-- in same or different class!!

============================================================================
 public enum Snow {
      BLIZZARD, SQUALL, FLURRY
      @Override public String toString() { return "Sunny"; }
   }

If an enum in Java contains anything other than a list of values (like methods), a semicolon (;) must follow the list of values. 
========================================================================================
package weather;

public class Forecast {
   public enum Snow {
      BLIZZARD, SQUALL, FLURRY;
      @Override public String toString() { return "Sunny"; }
   }

   public static void main(String[] modelData) {
      System.out.print(Snow.BLIZZARD.ordinal() + " ");
      System.out.print(Snow.valueOf("flurry".toUpperCase()));
   }
}
ordinal() returns the position of the enum constant in its enum declaration, where the first constant is assigned an ordinal of 0.
Snow.BLIZZARD.ordinal() returns 0 because BLIZZARD is the first constant.
Snow.valueOf("flurry".toUpperCase()) returns FLURRY, and the overridden toString() method returns "Sunny".
-----------------------------------------------------------------------------------------------------------------------------
=========================================== NB =================
it is possible to call a specific inherited default method, even when it has been overridden, it requires calling super, which is not accessible from a static method.
--------------------------------------------------

An enum method can be marked as abstract. When an enum method is abstract, it must be implemented by each constant of the enum. This allows different constants to have different behaviors for the method.

public enum Shape {
    CIRCLE {
        @Override
        double area() {
            return Math.PI * radius * radius;
        }
    },
    SQUARE {
        @Override
        double area() {
            return side * side;
        }
    };

    abstract double area();
    double radius; // Example property for illustration
    double side;   // Example property for illustration
}
----------------------------------------------------------------------

an enum can have constructors, and these constructors are used to initialize the constants of the enum. Enum constructors are similar to class constructors but are a bit more restrictive. Enum constructors are always private (or package-private), and you cannot use public or protected modifiers with them. 
public enum Shape {
    CIRCLE(3.0), 
    SQUARE(2.0);

    private double dimension;

    // Enum constructor
    Shape(double dimension) {
        this.dimension = dimension;
    }

    public double getDimension() {
        return dimension;
    }

    public double area() {
        switch (this) {
            case CIRCLE:
                return Math.PI * dimension * dimension;
            case SQUARE:
                return dimension * dimension;
            default:
                throw new UnsupportedOperationException("Unknown shape: " + this);
        }
    }

    public static void main(String[] args) {
        for (Shape shape : Shape.values()) {
            System.out.println(shape + " area: " + shape.area());
        }
    }
}
------------ ENUM METHODS CAN BE ABSTRACT -----------------

A static initializer block is used to initialize static variables or execute static code when the class is loaded into memory.It runs once, when the class is first loaded by the Java Virtual Machine (JVM).
public class Example {
    static {
        System.out.println("Static initializer block");
    }
    
    public static void main(String[] args) {
        // The static block will have already run before this line
        System.out.println("Main method");
    }
}
output: 
Static initializer block
Main method


Instance Initializer Block ({})
Purpose:
An instance initializer block is used to initialize instance variables or execute code that should run every time an instance of the class is created.
When It Runs:
It runs every time a new instance of the class is created, before the constructor of the class is called.
public class Example {
    {
        System.out.println("Instance initializer block");
    }
    
    public Example() {
        System.out.println("Constructor");
    }
    
    public static void main(String[] args) {
        Example example1 = new Example();
        Example example2 = new Example();
    }
}
==============================================================================

Local Variables:

Definition: Variables that are declared within a method or a block of code. They are only accessible within that method or block.
 Dot notation cannot be used to access local variables. 
---------------------------------------------

The reference type of unknownBunny could be any type that is a superclass or an implemented interface of Bunny, not necessarily Bunny or its subclasses.

unknownBunny could be any type that Bunny implements or extends, which includes interfaces, superclasses, or abstract classes.

if the Bunny class implements an interface (e.g., Runnable), the reference type of unknownBunny could be that interface. This is because in Java, interfaces define a contract that the implementing classes adhere to, allowing instances of those classes to be referenced by the interface type.


============ !!!! functional interface can have many mehtods but only ONE ABSTRACT METHOD!! ---------------------------------
an interface is considered a functional interface if it has exactly one abstract method. The presence of other methods that are not considered abstract (such as default methods, static methods, or methods from java.lang.Object) LIKE toString(); hashCode();
==================================================================================================

!!!!!! even though var is a reserved keyword for type inference, it can still be used as an identifier for class names and package names. 
---------------------------------------------------------------------------
============== !!NB: . A method may contain at most one varargs parameter, and it must appear as the last argument in the list.  ======================

The play() method is overridden in Violin for both MusicCreator and StringInstrument, so the return type must be covariant with both. Long is a subclass of Number, and therefore, 
-----------------------------------------------------------------------------

The IsoRightTriangle class is abstract; therefore, it cannot be instantiated
-------------------------------------------------------------------------------------------------------------------------------------

non-static method chaseTail() cannot be referenced from a static context:  private static void wagTail() { chaseTail(); }
----------------------------------------------------------------------------------------------------------------------------

How do you force garbage collection to occur at a certain point? !!NB: While you can suggest to the JVM that it might want to run a garbage collection cycle, the JVM is free to ignore your suggestion. garbage collection is not guaranteed to run
----------------------------------------------------------------------------------------------------------

The access modifier of strength is protected, meaning subclasses and classes within the same package can modify it.
-------------------------------------------------------------------------------------------------------------------

lambda expressions have certain rules regarding the variables they can reference. Here are the correct statements about referencing variables from a lambda, and an explanation:

Correct Statements:
Instance and static variables can be used regardless of whether effectively final.
Local variables and method parameters must be effectively final to be used.
Both local variables and method parameters must be effectively final to be accessed from within a lambda expression. This means the variable is not explicitly declared as final, but it is never modified after its initial assignment.
Both instance and static variables can be freely accessed from within a lambda expression. There are no restrictions on whether they need to be effectively final.
------------------------------------------------------------------------------------------
using null with the instanceof operator always returns false null instanceof Object
-----------------------------------------------------------------------------
!!! NB !!!!  option F does not compile as Dolphin is abstract and cannot be instantiated directly.
--------------------------------------------------------------------------------

============ ENUM=============================================
 enums are a special type of class that represents a group of constants. They can be defined inside another class or in a separate file. Enums can have fields, methods, and constructors, just like regular classes. While it is not recommended to change the value of an enum after it is created, it is legal
public class Eggs {
    enum Animal {
        CHICKEN(21), PENGUIN(75);

        private int numDays;

        private Animal(int numDays) {
            this.numDays = numDays;
        }

        public int getNumDays() {
            return numDays;
        }

        public void setNumDays(int numDays) {
            this.numDays = numDays;
        }
    }

    public static void main(String[] args) {
        Animal chicken = Animal.CHICKEN;
        chicken.setNumDays(20);

        System.out.print(chicken.getNumDays());
        System.out.print(" ");
        System.out.print(Animal.CHICKEN.getNumDays());
        System.out.print(" ");
        System.out.print(Animal.PENGUIN.getNumDays());
    }
}
Yes, exactly. The numDays field in the Animal enum is an instance variable that holds different values for each enum constant. Each constant (CHICKEN and PENGUIN) has its own separate value for numDays.

============================================================================
1: public interface Thunderstorm {
2:    float rain = 1;
3:    char getSeason() { return 'W'; }
4:    boolean isWet();
5:    private static void hail() {}
6:    default String location() { return "Home"; }
7:    private static int getTemp() { return 35; }
8: }
  Line 3 does not compile, as a method with a body within an interface must be explicitly marked static, default, or private, 
=================================================
The ordinal() method is a built-in method in Java's Enum class. It returns the ordinal value of the enum constant, which is its position in its enum declaration. The first constant is assigned an ordinal of zero, the second constant is assigned an ordinal of one, and so on.

Key Points:
The ordinal() method is final and cannot be overridden.
Ordinals are zero-based.
The ordinal value is primarily used for internal purposes and not recommended for persistence or business logic as the order of enum constants can change.
======================================================
public void nested() { nested(2,true); }
public int nested(int w, boolean h) { return 0; }
public static void main(String[] outOfTheBox) {
       System.out.print(new Dolls().nested()); // doesnt compile because tries to print void
   }
========================
A class can trivially be assigned to a superclass reference variable but requires an explicit cast to be assigned to a subclass reference variable.
=============================
public static void main(String[] ohMy) {
    String animal1 = new String("lion");
    String animal2 = new String("tiger");
    String animal3 = new String("bear");

    animal3 = animal1;  // animal3 now references the "lion" object
    animal2 = animal3;  // animal2 now references the same "lion" object as animal3
    animal1 = animal2;  // animal1 now references the same "lion" object as animal2
}
==================================================
If both Cub and Panther are interfaces, and there's an arrow pointing from Cub to Panther, it indicates that the Cub interface extends the Panther interface. In UML diagrams, this relationship is depicted with a solid line with a closed, unfilled arrowhead pointing from the child interface to the parent interface.
===================================================================================
Local Class
A local class is a class defined within a method, constructor, or initializer block. Local classes are similar to inner classes, but their scope is limited to the block of code in which they are defined. They are not accessible outside this block.

Characteristics of Local Classes:

Defined within a method, constructor, or initializer block.
Can access members of the enclosing class.
Can access local variables of the enclosing block under certain conditions.
Not accessible outside the block where they are defined.
Example:

java
Copy code
public class OuterClass {
    public void someMethod() {
        class LocalClass {
            public void printMessage() {
                System.out.println("Hello from LocalClass!");
            }
        }

        LocalClass local = new LocalClass();
        local.printMessage();
    }
}


Local Variable
A local variable is a variable declared within a method, constructor, or initializer block. The scope of a local variable is limited to the block in which it is declared. It cannot be accessed outside this block.

Characteristics of Local Variables:

Declared within a method, constructor, or initializer block.
Scope is limited to the block where it is declared.
Must be initialized before use.
Cannot have access modifiers (like public, private, etc.).

++++++++++++++++++ NB +++++++++++++++  A local class can access final or effectively final local variables, making options A and C the correct answer. Local variables cannot be marked private or static,
-----------------------------------------------------------------
1:  public class InitOrder {
2:     public String first = "instance";
3:     public InitOrder() {
4:        first = "constructor";
5:     }
6:     { first = "block";  }
7:     public void print() {
8:        System.out.println(first);
9:     }
10:    public static void main(String... args) {
11:       new InitOrder().print();
12:    }
13: }
When the main() method instantiates the object, line 2 first runs and sets the variable using the declaration. Then the instance initializer on line 6 runs. Finally, the constructor runs.
==========================================================

the term "cycle" usually refers to a circular dependency or circular reference in the code. This occurs when two or more classes, methods, or other entities depend on each other in a way that creates a loop, which the compiler or runtime environment cannot resolve.
===================================================================================
NOB!!! The variable VAR can be assigned null only after initial initialization.The type is determined based on the value at initialization. It cannot be null at that point, but the variable can be assigned as null later, 
=============================================
NB!!!  you cannot have a top-level class marked as static. The static keyword in Java can only be applied to nested (inner) classes. So when you refer to a "static class," it implies a static nested class within another class.
The main() method defines a local class Oak that correctly extends Tree, a static nested class. The method getWater() is not permitted to read the local variable water, though, since it is not final or effectively final, making option C correct. If the last line of the method was removed, though, then the program would compile and print 8.
public class Woods {
   static class Tree {}
   public static void main(String[] leaves) {
      int heat = 2;
      int water = 10-heat;
      final class Oak extends Tree {  // p1
         public int getWater() {
            return water;             // p2
         }
      }
      System.out.print(new Oak().getWater());
      water = 0;
   }
}
------------------------------------------------------------
The reason why the value of color is not changed in your code is due to a common mistake known as shadowing or variable shadowing. In the method setColor, the parameter color is shadowing the instance variable (or field) color, which prevents the method from modifying the instance variable.
public class SomeClass {
    private String color; // Instance variable

    public void setColor(String color) { // Method parameter
        color = color; // This line does not change the instance variable
    }
}
color is the param, u need this.color to refer to the field color
-----------------------------------------------------------------

NB!!! within a constructor, you can only use either this() or super() in the first line of the constructor, but not both. 
The reason you can't use both this() and super() in the same constructor is because both are meant to be the first operation within a constructor. Java's design enforces that the constructor either delegates to another constructor in the same class (this()), or it delegates to the constructor of the superclass (super()). Allowing both would create ambiguity and confusion in terms of which constructor should be executed first.
----------------------------

============= EXCEPTIONS EXPLAINED, STILL IN OBJECTS===========================
An exception in Java is an event that occurs during the execution of a program that disrupts the normal flow of instructions. When an error occurs, Java generates an object called an exception object. This object contains information about the error, such as its type and the state of the program when the error occurred.

Java exceptions are used to handle errors and other exceptional events in a program, allowing the program to continue or terminate gracefully.

====================================2. The Throwable Class========================

In Java, all exceptions are derived from the Throwable class. Throwable is the root class for everything that can go wrong in your program. It has two main subclasses:

****Exception: Represents conditions that a reasonable application might want to catch. These are errors that are recoverable in some way.

***Error: Represents serious problems that a reasonable application should not try to catch. These are typically system-level errors, like OutOfMemoryError, and are not meant to be caught.

============== 3. The Exception Class ========================
The Exception class is a subclass of Throwable and is the base class for all exceptions in Java that a programmer might want to catch and handle.

Types of Exceptions:
Checked Exceptions: These are exceptions that are checked at compile-time. If a method throws a checked exception, it must be either caught or declared in the method signature using the throws keyword.

Examples:
IOException
SQLException

Unchecked Exceptions (Runtime Exceptions): These are exceptions that occur during runtime and are not checked at compile-time. They do not need to be declared or caught. These typically indicate programming errors, such as logic errors or improper use of an API.

Examples:

NullPointerException
ArrayIndexOutOfBoundsException

==============4. The Error Class =================
Errors are exceptions that are not meant to be caught by typical application code. They represent serious problems and usually indicate something is wrong with the Java runtime environment.

Examples:

StackOverflowError
OutOfMemoryError
=====
finally Block: This block is optional and executes after the try and catch blocks, regardless of whether an exception was thrown or not. It's typically used to release resources like closing files or database connections.


====
===If a method can cause a checked exception and doesn’t handle it within the method, it must declare that it throws the exception using the throws keyword.

class CustomException extends Exception {
    public CustomException(String message) {
        super(message);
    }
}

public class Example {
    public static void main(String[] args) {
        try {
            validateAge(15);
        } catch (CustomException e) {
            System.out.println("Caught custom exception: " + e.getMessage());
        }
    }

    public static void validateAge(int age) throws CustomException {
        if (age < 18) {
            throw new CustomException("Age must be 18 or older.");
        }
    }
}

==============
 When overriding a method, the overriding method cannot declare to throw a broader checked exception than the method it overrides.
----------------------------
 Top‐level classes can be set only with public and package‐private access, making option A incorrect. On the other hand, member inner classes can be set with any of the four access levels, making option D incorrect. Both types of classes can be declared with final or abstract modifier, making option B incorrect and option F correct. Both can also include constructors, making option C correct. Finally, option E is correct and one of the primary features of inner classes: Both can be marked abstract.
======================================

----- NB ------------
a class declaration is the only required component in a Java class file. Note that we said a Java class file here; Java also allows interfaces, annotations, modules, and enums to be defined in a file. A class file may have a single package statement or any number of import statements. Neither is required.
------------------------------------

Both the Drive and Hover interfaces define a default method getSpeed() with the same signature. The class Car implements both interfaces, which means it inherits both default methods. Since the compiler does not know which one to choose, the Car class must override the default method. Since it does not, the code does not compile, and option D is correct. Note that the RaceCar class does properly override the default method, the problem is with the Car class.

=================================

The super() call in the constructor (line 2) is fine because every class in Java implicitly extends the Object class unless it explicitly extends another class.
super() calls the constructor of the superclass. In this case, ChooseWisely has no explicit superclass, so super() calls the constructor of the Object class, which is the default behavior for any class in Java that doesn’t extend another class.
----------------------------------
 System.out.println(c.choose((byte)2+1));
the value 2 is first cast to a byte. It is then increased by one using the addition + operator. The addition + operator automatically promotes all byte and short values to int.
Note that without the addition operation in the main() method, byte would have been used as the parameter to the choose() method, causing the choose(short) to be selected as the next closest type and outputting 2, making option A the correct answer.
===============================

2f is a float literal.

Java Method Selection Order:

Java prefers widening conversion over autoboxing.
Widening: float → double (which matches choose(double choice)).
Autoboxing to Float comes after widening.
Result:

choose(double choice) matches first, so the output is 6, not 8 from choose(Float choice).

=====================================================
An interface can be extended by another interface and a class can be extended by another class. This makes the second part of options A, D, and E incorrect. Among nested classes, all types can be extended except an anonymous class since it does not declare a class name, making option F correct and both parts of option B incorrect. Option C is correct because an enum cannot be extended.
===================================================

Enum values are considered constants and are commonly written using snake case, often stylized as snake_case. This style uses an underscore ( _) to separate words with constant values commonly written in all uppercase. For example, an enum declaring a list of ice cream flavors might include values like VANILLA, ROCKY_ROAD, MINT_CHOCOLATE_CHIP, and so on.

Behind the scenes, an enum is a type of class that mainly contains static members. It also includes some helper methods like name(). 
Season s = Season.SUMMER;
System.out.println(Season.SUMMER); // SUMMER
System.out.println(s == Season.SUMMER); // true
As you can see, enums print the name of the enum when toString() is called. They can be compared using == because they are like static final constants. In other words, you can use equals() or == to compare enums, since each enum value is initialized only once in the Java Virtual Machine (JVM).Season s = Season.valueOf("SUMMER"); // SUMMER
One thing that you can't do is extend an enum.
public enum Season {
2:    WINTER("Low"), SPRING("Medium"), SUMMER("High"), FALL("Medium");
3:    private final String expectedVisitors;
4:    private Season(String expectedVisitors) {
5:       this.expectedVisitors = expectedVisitors;
6:    }
7:    public void printExpectedVisitors() {
8:       System.out.println(expectedVisitors);
9:    } }
 We mark the instance variable final on line 3 so that our enum values are considered immutable. Although this is certainly not required, it is considered a good coding practice to do so. Since enum values are shared by all processes in the JVM, it would be problematic if one of them could change the value inside an enum.
======= NB ======================
All enum constructors are implicitly private, with the modifier being optional. This is reasonable since you can't extend an enum and the constructors can be called only within the enum itself. An enum constructor will not compile if it contains a public or protected modifier.
------------------------------
How do we call an enum method? It's easy.


Season.SUMMER.printExpectedVisitors();
Notice how we don't appear to call the constructor. We just say that we want the enum value. The first time that we ask for any of the enum values, Java constructs all of the enum values. After that, Java just returns the already constructed enum values. Given that explanation, you can see why this calls the constructor only once:


public enum OnlyOne {
   ONCE(true);
   private OnlyOne(boolean b) {
      System.out.print("constructing,");
   }
}

public class PrintTheOne {
   public static void main(String[] args) {
      System.out.print("begin,");
      OnlyOne firstCall = OnlyOne.ONCE;  // prints constructing,
      OnlyOne secondCall = OnlyOne.ONCE; // doesn't print anything
      System.out.print("end");
   }
}
===========================
public enum Season {
   WINTER {
      public String getHours() { return "10am-3pm"; }
   },
   SPRING {
      public String getHours() { return "9am-5pm"; }
   },
   SUMMER {
      public String getHours() { return "9am-7pm"; }
   },
   FALL {
      public String getHours() { return "9am-5pm"; }
   };
   public abstract String getHours();
}
===================================================

If we don't want each and every enum value to have a method, we can create a default implementation and override it only for the special cases.


public enum Season {
   WINTER {
      public String getHours() { return "10am-3pm"; }
   },
   SUMMER {
      public String getHours() { return "9am-7pm"; }
   },
   SPRING, FALL;
   public String getHours() { return "9am-5pm"; }
}
===========================================================
in each of these enum examples, the list of values came first. This was not an accident. Whether the enum is simple or contains a ton of methods, constructors, and variables, the compiler requires that the list of values always be declared first.
-----------------------------------------
 ========== WORD FINAL =============================
Marking a method or class final means it cannot be overridden or extended, 
private void printZooInfo(boolean isWeekend) {
   final int giraffe = 5;
   final long lemur;
   if(isWeekend) lemur = 5;
   else lemur = 10;
   System.out.println(giraffe+" "+lemur);
}
As shown with the lemur variable, we don't need to assign a value when a final variable is declared. The rule is only that it must be assigned a value before it can be used.
The compiler does not allow the use of local variables that may not have been assigned a value, whether they are marked final or not.
---------------------------------------------------------------
Just because a variable reference is marked final does not mean the object associated with it cannot be modified. Consider the following code snippet:


final StringBuilder cobra = new StringBuilder();
cobra.append("Hssssss");
cobra.append("Hssssss!!!"
In the cobra example, the object reference is constant, but that doesn't mean the data in the class is constant.

Instance and static class variables can also be marked final. If an instance variable is marked final, then it must be assigned a value when it is declared or when the object is instantiated. Like a local final variable, it cannot be assigned a value more than once, though.

public class PolarBear {
   final int age = 10;
   final int fishEaten;
   final String name;

   { fishEaten = 10; }

   public PolarBear() {
      name = "Robert";
   }
   public PolarBear(int height) {
      this();
   }
}
The age variable is given a value when it is declared, while the fishEaten variable is assigned a value in an instance initializer. The name variable is given a value in the no‐argument constructor. Notice that the second constructor does not assign a value to name, but since it calls the no‐argument constructor first, name is guaranteed to be assigned a value in the first line of this constructor.

====== NB ===========
public class Panda {
   final static String name = "Ronda";
   static final int bamboo;
   static final double height; // DOES NOT COMPILE
   static { bamboo = 5;}
}
The name variable is assigned a value when it is declared, while the bamboo variable is assigned a value in a static initializer. The height variable is not assigned a value anywhere in the class definition, so that line does not compile.
-----------------------------
An abstract method is one that does not define a method body and can appear only inside an abstract class or interface. 
-------------------------
abstract and final? doesnt compile
---------------------------
public final class Reptile {}

public class Snake extends Reptile {} // DOES NOT COMPILE
Like we saw with final methods, classes cannot be marked both abstract and final. 
public abstract final class Eagle {} // DOES NOT COMPILE

public final interface Hawk {} // DOES NOT COMPILE

---------------------------------------

A nested class can come in one of four flavors.

Inner class: A non‐ static type defined at the member level of a class

Static nested class: A static type defined at the member level of a class

Local class: A class defined within a method body

Anonymous class: A special case of a local class that does not have a name

 interfaces and enums can be declared as both inner classes and static nested classes, but not as local or anonymous classes.
====================
An inner class, also called a member inner class, is a non‐ static type defined at the member level of a class (the same level as the methods, instance variables, and constructors). Inner classes have the following properties:

Can be declared public, protected, package‐private (default), or private

Can extend any class and implement interfaces

Can be marked abstract or final

NB!!! -> Cannot declare static fields or methods, except for static final fields

Can access members of the outer class including private members

========================
 Line 3 does not compile because printColor() is marked final and cannot be overridden. Line 5 does not compile because the method toSpectrum() is marked abstract and must be overridden by each enum value. Finally, line 6 does not compile because enum constructors are implicitly private. For these three reasons, option D is correct.
==========================
In Java, when you define methods inside an enum constant, you do not need to place a semicolon after each method. The semicolon is only required to terminate the entire enum constant's body === NB ========
===============================
A concrete class is not allowed to have abstract methods, but the other two types are. This makes the second row in the first column incorrect. All three types are allowed to have static final constants, making the whole second column correct. In the last column, there are two errors. An abstract class can have a constructor, but an interface cannot. Note that an abstract class cannot be instantiated. Instead, it requires a subclass. 
---------------------------------------------

!!!!   A functional interface must have exactly one abstract method, which is option B. There are no restrictions on the number of private or static methods,
------------------------------------
One of the motivations for adding default interface methods to Java was for backward compatibility. These methods allow developers to update older classes with a newer version of an interface without breaking functionality in the existing classes, making option B correct. Option E is also correct, as classes implementing the interface can share common methods. Option A is incorrect, as interface methods can already be overloaded. Option C is incorrect because methods in interfaces cannot be marked final. Option D sounds plausible, but could be accomplished with static interface methods alone. 
=========================
An instance of one class may access an instance of another class's attributes if it has a reference to the instance and the attributes are declared public.


An instance of one class may access an instance of another class's attributes if both classes are located in the same package and marked protected.

Two instances of the same class may access each other's private attributes.
============
Class names follow the same requirements as other identifiers. Underscores (_) and dollar signs ($) are allowed, but no other symbols are allowed
----------
Package-private means that the member (class, method, variable, etc.) is accessible only within its own package.
If you don’t specify public, protected, or private for a class, method, or variable, Java assigns package-private access by default.
--------------------
1:  public class A {
2:     private int x = 10;
3:     class B {
4:        private int x = 20;
5:        class C {
6:           private int x = 30;
7:           public void allTheX() {
8:              System.out.println(x);        // 30
9:              System.out.println(this.x);   // 30
10:             System.out.println(B.this.x); // 20
11:             System.out.println(A.this.x); // 10
12:    } } }
13:    public static void main(String[] args) {
14:       A a = new A();
15:       A.B b = a.new B();
16:       A.B.C c = b.new C();
17:       c.allTheX();
18: }}
======================================================
 An anonymous class can implement a single interface, and a top‐level class can implement any number of interfaces. Since a functional interface is an interface with additional rules, both anonymous class and top‐level class are correct. Additionally, a lambda expression can also implement a functional interfac
===========
we hebben veel overeinkomsten - we have a lot in common we hebben veel gemeen
===================
interface Fruit {
   public default char getColor() { return 'F'; }
}
interface Edible  {
   public default char getColor() { return 'E'; }
}
public class Banana implements Fruit, Edible {
   public char getColor() { return ________Edible.super.getColor()____; }
   public static void main(String[] a) {
      var d = new Banana();
      System.out.println(d.getColor());
   }
} // prints out: E

----------------
In Java, the execution of static blocks, instance initializer blocks, and constructors follows a specific order when a class is loaded and an object is created. Here's a detailed explanation of how this order influences the output of the program:

1. Static Blocks:
Static blocks are executed when the class is loaded into the memory. They run only once, regardless of how many objects of the class are created.
Execution Order: Static blocks are executed in the order they appear in the class.
---------------------------------
Static blocks execute first: re-fa-
main method begins: Prints ti-
Instance initializer blocks execute: do-mi-
Constructor executes: so-
===========================================

Remember that all nested classes can have static variables if they are marked final.
================================================

using null with instanceof compiles, it always returns false.  boolean n = null instanceof Bus;
================
, all methods in an interface are abstract by default unless they are static or default methods. Therefore, the abstract modifier is not required and should not be listed under required modifiers. Additionally, all methods in an interface are implicitly public, so public is also not needed but can be stated. 
======================
If the assignment in the constructor was changed to this.name, then the program would compile and print Sleepy.
====================
There is no such thing as package variables,
===========================

The default no‐argument instructor is inserted by the compiler whenever a class, abstract or concrete, does not declare any constructors. Even if a parent class does not declare a no‐argument constructor, the child class can still declare one. If the parent class does not declare a no‐argument constructor (and none is inserted by the compiler), then the child class must declare at least one constructor, making option C correct. Without a constructor call, inserting the default no‐argument constructor into the child class would lead to a compiler error on the implicit super() call. child class of a parent with a no‐argument constructor is free to declare or not declare any constructors.
================

Interfaces allow Java to support multiple inheritance because a class may implement any number of interfaces. On the other hand, an anonymous class may implement or extend at most one interface or class, respectively, since it does not have a class definition.
======================
interfaces can have private methods: Increase code reuse within the interface.Improve encapsulation of the interface.
==========
when u call a private method from another class in your class, your class doesnt compile, the another class compiles
====

static initilizer: class Example {
    static {
        // Initialization code here
        System.out.println("Static initializer block executed.");
    }
}
=====
You can use it to perform operations that need to happen only once for a class, such as loading configuration settings or initializing large static data structures.
Limitations:

Since static initializers are run when the class is loaded, they can make class loading slower if they contain time-consuming operations.
If an exception is thrown during the execution of a static initializer, the class will fail to load, and a ExceptionInInitializerError will be thrown.
================

A static initializer can create instances of any class it has access to
==================
 you can have private methods in an interface in Java, 
=================
An instance method can access both instance variables and static variables
==========================
 class Fly {
2:    public Fly Fly() { return Fly(); }
3:    public void Fly(int kite) {}
4:    public int Fly(long kite) { return 1; }
5:    public static void main(String[] a) {
6:       var f = new Fly();
7:       f.Fly();
8:    }
9: } == COMPILES ===========


When overriding a method, a new or broader checked exception cannot be declared.
=========================
 Having one class implement two interfaces that both define the same default method signature leads to a compiler error unless the class overrides the default method
===============================
 Note that the return types of the two default methods are different, but the overridden method uses a return type that is covariant with both.
==================================
CharSequence is an interface that represents a sequence of characters. It is part of the java.lang package and serves as the root interface for a number of classes that handle sequences of characters, such as String, StringBuilder, StringBuffer, and CharBuffer.

Key Points About CharSequence:
Interface Methods:
CharSequence defines several methods that are commonly needed when working with sequences of characters. These include:

char charAt(int index): Returns the character at the specified index.
int length(): Returns the length of the character sequence.
CharSequence subSequence(int start, int end): Returns a new CharSequence that is a subsequence of the current sequence.
String toString(): Returns a String containing the characters in this sequence.
Common Implementations:
Several classes implement the CharSequence interface, each serving different purposes:

String: Represents an immutable sequence of characters.
StringBuilder: Represents a mutable sequence of characters, which is not thread-safe.
StringBuffer: Similar to StringBuilder, but is thread-safe.
CharBuffer: A buffer for handling sequences of characters, part of the java.nio package.
Usage:

CharSequence is often used when you need to work with a sequence of characters in a flexible way. By using CharSequence as a type, you can write methods that accept any kind of character sequence, whether it's a String, StringBuilder, or another implementation.
CharSequence cs = "Hello, World!";
System.out.println(cs.length());         // Outputs: 13
System.out.println(cs.charAt(0));        // Outputs: H
System.out.println(cs.subSequence(7, 12)); // Outputs: World

CharSequence is a fundamental interface in Java that represents a readable sequence of characters. It’s implemented by various classes, including String, StringBuilder, and StringBuffer, allowing for flexible handling of character sequences. By using CharSequence as a type, you can create methods that are more generic and work with any character sequence, providing better code reuse and abstraction.
===============================

the contents of the class can still be changed, even if the class is marked final.
=======================================
that all variables within interfaces are implicitly static and final !!!!!!!!!
====================================
Overloaded methods always have the same name but a different list of parameters,
======================================================
Before banana = null:

orange -> y -> banana
banana -> z -> orange
There is a circular reference between orange and banana.

When banana = null:

The reference to the banana object in the main method is set to null.
However, the banana object itself still exists in memory because orange.next still points to it.
The circular link between orange and banana remains intact:

orange -> y -> banana
banana -> z -> orange
Conclusion:
Setting banana = null does not change orange.next. The orange object still has its next reference pointing to the banana object, which in turn still points back to orange. The circular structure between orange and banana remains unaffected.
=================================

 If a class extends a parent class that does not include a no‐argument constructor, the default no‐argument constructor cannot be automatically inserted into the child class by the compiler. Instead, the developer must explicitly declare at least one constructor and explicitly define how the call to the parent constructor is made.
===================================

 Interface methods are public, whereas the override in the anonymous class uses package‐private access

=====================================
While an abstract class cannot be marked final, a concrete class extending it can be. a concrete method overriding an abstract one can also be marked final. 
========================================================================
The Sheep class does not compile because there is no default access modifier keyword.
========================================================
Marking an interface method private improves the encapsulation of the class.
These methods can only be used within the interface itself and are typically used to share common code among other methods in the interface, like default or static methods. Private methods in interfaces cannot be accessed by the implementing classes or other code outside the interface.
=================================================================

Hi Emma, i feel i would like to share something with you: i found your website and you wrote about something really close to my heart: the fullness of expression and emboding everything what arises with all its craziness and range (shame, brokeness, admiration, sensuality, strength, vulnarability, staying open, feeling it...) It all makes sense: I imagine that what i saw in your eyes in the silent SL and it felt i met an equal, that I could be fully met. and in my life this is only the second time i experienced this. so, just wanted to say: it was awesome.
=========================================
  The play() method is overridden in Saxophone for both Horn and Woodwind, so the return type must be covariant with both.
===========================================================

Short: Since Short is final, the only covariant return type possible is Short.
Integer: Since Integer is final, the only covariant return type possible is Integer.
=========================

An abstract class can be extended by a final class.

An abstract method can be overridden by a final method.

An abstract class can be extended by multiple classes directly.
 Since package‐private is a more restrictive access than protected,
========================
When declaring a class, the name comes first, before instance declarations,

Java does not support fragments of code outside of a top‐level type, such as a class or interface, making option F incorrect.

===============
In languages like C or C++, macros are a feature of the preprocessor, allowing you to define code snippets or constants that can be reused throughout your code. These are typically defined using #define directives. Macros are essentially text substitutions that occur before the actual compilation process.

Java does not have a preprocessor, so it does not support macros. Instead, Java encourages the use of methods, constants, and other language constructs to achieve similar functionality in a cleaner and more controlled way.
In Java, code reuse and modularity are accomplished using methods, classes, and interfaces, rather than macros.
Why Macros are Not Used in Java:

Macros can lead to code that is difficult to debug and maintain because they are expanded before compilation, and errors related to them can be hard to trace.
Java focuses on object-oriented principles and type safety, which macros can undermine by allowing unchecked substitutions and manipulations.
=============================

Interfaces cannot contain protected methods, 
================================================
ptions A and D would not allow the class to compile because two methods in the class cannot have the same name and arguments, but a different return value
Option B is a valid overloaded version of the findAverage() method, since the name is the same but the argument list differs.
================================================

Method overloading in Java is a feature that allows a class to have more than one method with the same name, but with different parameters. The differences can be in the number of parameters, their types, or both.
Overloaded methods can have different access modifiers (e.g., public, private), but it’s not a requirement for overloading.
You cannot overload methods by just changing the return type; the parameter list must be different.
method overloading in Java is determined solely by the method's parameter list—that is, the number, type, and order of the parameters. The return type of the methods does not play a role in differentiating overloaded methods.
void print(int a) {}        // Method 1
void print(double b) {}     // Method 2 (overloaded based on different parameter type)
void print(int a, int b) {} // Method 3 (overloaded based on different number of parameters)

int calculate() { return 1; }    // Method 1
double calculate() { return 1.0; } // Method 2 - This would cause a compile-time error because the parameter list is the same.


===========================================
A method name must start with a letter, the dollar ($) symbol, or an underscore (_) character.
========================
private methods in interfaces do not need to be implemented by classes that implement the interface. 
------------------------------------------
The code does not compile because two of the constructors contain a cyclic reference to each other. The MoreMusic(int) constructor calls this(null), which only matches the MoreMusic(String) constructor
=========================================
If used, this() must be the first statement in the constructor.
It cannot be used in combination with super() in the same constructor, since both this() and super() must be the first statement.

public MoreMusic(int note) {
    this(null); // Calls the constructor MoreMusic(String song)
    System.out.print("fa-");
}

public MoreMusic(String song) {
    this(9); // Calls the constructor MoreMusic(int note)
    System.out.print("so-");
}

Before any constructor executes its code, the instance initializer block ({ System.out.print("do-"); System.out.print("re-"); }) is executed each time a constructor is invoked. Therefore, "do-re-" is printed twice during the execution flow.
===========================

   A switch statement that uses an enum must include case statements that reference the value of the enum, without the enum type. For this reason, option A is correct and option C is incorrect. The ordinal() value or position cannot be used in case statements when the switch statement takes an enum value, making option B correct and option E incorrect. Finally, not every value in enum must be present in the case statement, regardless of whether a default branch is present, making options D and F incorrect.

========================================

In the code you provided, there are two different first variables declared:

static int first in the Ready interface:

Declared as static int first = 2; within the Ready interface.
This variable is implicitly public, static, and final because it is a field in an interface. This means it is a constant, and it cannot be modified or overridden by any implementing class.
The value of first in this context is 2.
int first in the GetSet class:

Declared as a non-static instance variable int first = 5; within the GetSet class.
This is a separate variable from the first variable in the Ready interface. It is an instance variable specific to objects of the GetSet class.

No, they are not the same. The first variable in the Ready interface and the first variable in the GetSet class are distinct variables. The former is a static and final constant in the interface, while the latter is a regular instance variable in the class.
Yes, the code compiles without issues. The first variable in the Ready interface is a static final constant, so it doesn't conflict with the instance variable first in the GetSet class.

In Java 11, the code r.first will compile, and it will access Ready.first (the static field from the interface), not the first in GetSet. This behavior is allowed because the interface Ready is within the scope of the anonymous class, and the first field in the interface is static.
======================================
The Sheep class does not compile since a static method cannot call an instance method. 
------------------------------
The Rotorcraft class includes an abstract method, but the class itself is not marked abstract.
Only interfaces and abstract classes can include abstract methods
========================================

All of the interface methods without a private modifier are implicitly public. 
In a class, though, a method without a modifier is package‐private by default.
---------------------------------
 class Source implements Power {};
5:       final class Super extends Source {};
6:       var start = new Super() {};

The Super class is marked final, which mean its cannot be used as the supertype of an anonymous class. 
 Line 7 also does not compile as a local class can only contain static variables that are marked final.

!!!!  final variable DEFAULT_VALUE is not a static variable
======================
The static class variables cannot be used with var since they are not local variables. Therefore, options E and F are incorrect. Options B and C are correct because numeric addition is used here instead of concatenation.:

public class Values {
   static ____  defaultValue = 8;
   static ____ DEFAULT_VALUE;

   public static void main(String[] args) {
      System.out.println(defaultValue + DEFAULT_VALUE);
   }
}
When you fill in both blanks with double, it prints 8.00.0

When you fill in both blanks with double, it prints 8.0

When you fill in both blanks with int, it prints 8

In Java, when you declare a static variable of a primitive type (like int or double) without initializing it, it automatically gets a default value.
For an int, the default value is 0.
For a double, the default value is 0.0.
Behavior with int:

If you fill in both blanks with int, like this:
java
Copy code
static int defaultValue = 8;
static int DEFAULT_VALUE;
The defaultValue variable is explicitly initialized to 8.
The DEFAULT_VALUE variable is not explicitly initialized, so it gets the default value of 0.
==================

Since only constructors can call super(), the code does not compile due to this line
 var equipment = (Equipment)(Ball)new SoccerBall().get(); this is ok
=====================

.   The question may appear to be about method overriding, but it is in fact about member inner classes. In fact, all of the method overrides are valid in this class. The code does not compile because the charge() method is static (even though it is called on an instance), which means it requires an instance to instantiate a member of the member inner class MyTrunk. For this reason, the call to new MyTrunk() does not compile, :
interface Long {
   Number length();
}
public class Elephant {
   public class Trunk implements Long {
      public Number length() { return 6; }   // k1
   }
   public class MyTrunk extends Trunk {      // k2
      public Integer length() { return 9; }  // k3
   }
   public static void charge() {
      System.out.print(new MyTrunk().length());
   }
   public static void main(String[] cute) {
      new Elephant().charge();               // k4
   }
}
===========================

!!!!!!!!!! The line float value = 102.0; does not compile because the literal 102.0 is treated as a double by default in Java, not a float. In Java, assigning a double value to a float variable without explicit casting causes a compilation error because of potential precision loss.

Explanation:
Double vs. Float: In Java, 102.0 is a double literal. A double has more precision (64 bits) compared to a float (32 bits).
Type Mismatch: Java requires you to explicitly state when you want to assign a double to a float, as it might result in a loss of precision. The compiler does not automatically downcast from double to float. !!!!!!!!!!!!!!!!!
float value = 102.0f; // This compiles
float value = (float) 102.0; // This also compiles
The reason float value = 102.0; does not compile is that 102.0 is treated as a double, and you cannot directly assign a double to a float without explicit casting or using a float literal (102.0f).

=============================

 new Puma() attempts to create an instance of Puma, but Puma is an abstract class. Abstract classes cannot be instantiated directly. This will result in a compilation error
!!!!!!
When you implement an interface method, the access level of the implementing method cannot be more restrictive than the access level specified in the interface.
Since interface methods are public, the implementing methods in a class must also be public. You cannot use protected, default (package-private), or private access levels because they would restrict access to the method in a way that violates the contract of the interface.
!!!!!!!!!!!
==============================
How many times is the word true printed?

 var s1 = "Java";
 var s2 = "Java";
 var s3 = "Ja".concat("va");
 var s4 = s3.intern();
 var sb1 = new StringBuilder();
 sb1.append("Ja").append("va");
 
 System.out.println(s1 == s2);
 System.out.println(s1.equals(s2));
 System.out.println(s1 == s3);
 System.out.println(s1 == s4);
 System.out.println(sb1.toString() == s1);
 System.out.println(sb1.toString().equals(s1));

s1 == s2: true (same string literal pool)
s1.equals(s2): true (same content)
s1 == s3: false (different objects) //s3 is created using concat(), which creates a new string object, not using the string pool.
s1 == s4: true (s4 is interned, refers to same pool object as s1)
sb1.toString() == s1: false (different objects)
sb1.toString().equals(s1): true (same content)

===============
Java intern() Method Tutorial
The intern() method in Java is used to manage memory more efficiently by ensuring that identical strings are stored only once in the string pool. Here's a step-by-step explanation:

What is the String Pool?
The String Pool (also known as the interned string pool) is a special area in the Java heap memory where string literals are stored.
When you create a string literal, Java checks if it already exists in the pool. If it does, the existing reference is returned; if not, the literal is added to the pool.

Creating Strings:

String literals are automatically placed in the string pool.
Strings created with new String() or by methods like concat() do not go into the pool automatically—they create separate objects on the heap.
Using intern():

intern() checks if a string with the same content exists in the pool.
If it exists, intern() returns the reference from the pool.
If it doesn’t exist, intern() adds the string to the pool and returns its reference.

String s1 = "Java";               // Stored in the string pool
String s2 = new String("Java");   // Stored in heap, not in the pool
String s3 = s2.intern();          // s3 now refers to the string in the pool

System.out.println(s1 == s2);     // false, different references (heap vs pool)
System.out.println(s1 == s3);     // true, both refer to the pool string

Memory Efficiency: Reduces memory usage by ensuring identical strings are stored only once in the pool.
Faster Comparisons: Using == for reference comparison is faster than equals() for content comparison when strings are interned.

The String Pool (also known as the interned string pool) in Java is a special memory area inside the heap where string literals are stored. The primary purpose of the string pool is to optimize memory usage and improve performance by storing only one copy of each distinct string value.
When you create a string using a string literal, Java automatically places that string in the pool.
String s1 = "Hello";  // "Hello" is placed in the string pool
String s2 = "Hello";  // s2 references the same "Hello" in the string pool
In the example above, s1 and s2 refer to the same memory location in the string pool.
Strings created with new String("Hello") are stored in the heap, not directly in the pool.
String s3 = new String("Hello");  // Creates a new object on the heap
===================

The code does not compile because Java allows at most one public class in the same file. 
========================================
test(i ‐> {i == 5;}) //  incorrect because a return statement must be used if braces are included around the body.
===========
 In practice, you can write any of the following:


String[] args
String args[]
String... args;
!!! NB !!! All command-line arguments are treated as String objects, even if they represent another data type like a number:
==================
The import statement tells the compiler which package to look in to find a class.

 Java archive (JAR) file is like a zip file of mainly Java class files.
===========
A file is also allowed to have neither class be public.
===============
The package java.lang is special in that it does not need to be imported.
========================
Package and import statements are optional.
======================
Fields and methods are also optional and are allowed in any order within the class declaration.
============================
. This example is using the single-file source-code launcher. It compiles in memory rather than creating a .class file, making option A incorrect. To use this launcher, programs can only reference classes built into the JDK. Therefore, option B is incorrect, and options C and D are correct.
''''''''''''''''''''''''''''''''''''
If the CLASSPATH is not set explicitly, Java uses the default classpath, which is:

The Current Directory (.): By default, the JVM looks in the current directory from where the Java program is executed. This means that if your compiled .class files are in the current directory, they will be found and executed successfully.
Standard Java Libraries: The JVM will also always look in the standard libraries that come with the Java Development Kit (JDK), such as those in java.lang, java.util, etc.
''''''''''''''''''''''''''''''''''''''''''''''
'

included in JDK: JVM

javadoc

jar, javac
======================
When compiling with javac, you can specify a classpath with -cp or a directory with -d, 
=================================

Option	javac	java	jar Command
-c			✓
-C			✓
-cp	✓	✓	✓
-CP			
-d	✓		
-f			✓
-p			
===============================
-cp classpath
-d dir // javac
-c  // jar creates new jar file
-C // changes dir b4 other operations
-f // jar: jar file name
================================
The package name represents any folders underneath the current path


for (int i = 0; i < length; i++) {
            int currentValue = TABLE.get(s.charAt(i));
            if (i + 1 < length && currentValue < TABLE.get(s.charAt(i + 1))) {
                result -= currentValue;
            } else {
                result += currentValue;
            }
        }
===============
boolean true or false                example: true
byte    8-bit integral value         example: 123
short   16-bit integral value        example: 123
int     32-bit integral value        example: 123
long    64-bit integral value        example: 123L
float   32-bit floating-point value  example: 123.45f
double  64-bit floating-point value  example: 123.456
char    16-bit Unicode value         example: 'a'
============================

All of the numeric types are signed in Java. This means that they reserve one of their bits to cover a negative range. For example, byte ranges from -128 to 127. You might be surprised that the range is not -128 to 128. Don’t forget, 0 needs to be accounted for too in the range
=================
For the exam, you should be aware that short and char are closely related, as both are stored as integral types with the same 16-bit length. The primary difference is that short is signed, which means it splits its range across the positive and negative integers. Alternatively, char is unsigned, which means range is strictly positive including 0. Therefore, char can hold a higher positive numeric value than short, but cannot hold any negative numbers.
The compiler allows them to be used interchangeably in some cases, as shown here:


short bird = 'd';
char mammal = (short)83;
Printing each variable displays the value associated with their type.


System.out.println(bird);   // Prints 100
System.out.println(mammal); // Prints S

short reptile = 65535;  // DOES NOT COMPILE
char fish = (short)-1;  // DOES NOT COMPILE
================

In most computer systems, floating-point numbers are stored in scientific notation. This means the numbers are stored as two numbers, a and b, of the form a x 10b.
For example, you can store a value of 3 x 10200 in a double,
This notation allows much larger values to be stored, at the cost of accuracy. For example, you can store a value of 3 x 10200 in a double, which would require a lot more than 8 bytes if every digit were stored without scientific notation (84 bytes in case you were wondering). To accomplish this, you only store the first dozen or so digits of the number. The name scientific notation comes from science, where often only the first few significant digits are required for a calculation.
===================
The number of bits is used by Java when it figures out how much memory to reserve for your variable. For example, Java allocates 32 bits if you write this: int num;
long max = 3123456789L;  // now Java knows it is a long
The last thing you need to know about numeric literals is that you can have underscores in numbers to make them easier to read:
int million1 = 1000000;
int million2 = 1_000_000;

We’d rather be reading the latter one because the zeros don’t run together. You can add underscores anywhere except at the beginning of a literal, the end of a literal, right before a decimal point, or right after a decimal point. You can even place multiple underscore characters next to each other, although we don’t recommend it.

Let’s look at a few examples:


double notAtStart = _1000.00;          // DOES NOT COMPILE
double notAtEnd = 1000.00_;            // DOES NOT COMPILE
double notByDecimal = 1000_.00;        // DOES NOT COMPILE
double annoyingButLegal = 1_00_0.0_0;  // Ugly, but compiles
double reallyUgly = 1__________2;      // Also compiles
=====================

A reference type refers to an object (an instance of a class). Unlike primitive types that hold their values in the memory where the variable is allocated, references do not hold the value of the object they refer to. Instead, a reference “points” to an object by storing the memory address where the object is located, a concept referred to as a pointer. Unlike other languages, Java does not allow you to learn what the physical memory address is. You can only use the reference to refer to the object.

!!! NB !!! First, reference types can be assigned null, which means they do not currently refer to an object. Primitive types will give you a compiler error if you attempt to assign them null.

reference types can be used to call methods, assuming the reference is not null.
a var can be named $ but not _
. Remember that Java is case sensitive, so you can use versions of the keywords that only differ in case. Please don’t, though.
*] The reserved words const and goto aren’t actually used in Java. They are reserved so that people coming from other programming languages don’t use them by accident—and in theory, in case Java wants to use them one day.

!! double public;       // public is a reserved word
Class and interface names are written in camelCase with the first letter being uppercase. Also, don’t start any class name with $, as the compiler uses this symbol for some files.

==============

In Java, volatile ensures that changes to a variable are immediately visible to all threads, preventing caching issues in multi-threaded environments.
==========================

Oracle (and Sun before it) recommends everyone use camelCase for class and variable names. There are some exceptions, though. Constant static final values are often written in snake_case, such as THIS_IS_A_CONSTANT. In addition, enum values tend to be written with snake_case, as in Color.RED, Color.DARK_GRAY, and so on.
=============
int num, String value; // DOES NOT COMPILE
A local variable is a variable defined within a constructor, method, or initializer block. Local variables do not have a default value and must be initialized before use.
============
 class variable because it has the keyword static before it.
===================
!!! NB !!!!!!!!!!!
Instance and class variables do not require you to initialize them. As soon as you declare these variables, they are given a default value. You’ll need to memorize everything in Table 2.3 except the default value of char. To make this easier, remember that the compiler doesn’t know what value to use and so wants the simplest value it can give the type: null for an object and 0/false for a primitive.

Table 2.3: Default initialization values by type
Variable type

Default initialization value

boolean

false

byte, short, int, long

0

float, double

0.0

char

'\u0000' (NUL)

All object references (everything else)

null
==========
public void whatTypeAmI() {
   var name = "Hello"; // local var: compiles
   var size = 7;
}
The formal name of this feature is local variable type inference. Let’s take that apart. First comes local variable. This means just what it sounds like. You can only use this feature for local variables. The exam may try to trick you with code like this:


public class VarKeyword {
   var tricky = "Hello"; // DOES NOT COMPILE: instance var
}
The variable tricky is an instance variable. Local variable type inference works with local variables and not instance variables.
=====================

the byte can be automatically promoted to a short, because a byte is small enough that it can fit inside of short. 
 public void twoTypes() {
5:    int a, var b = 3;  // DOES NOT COMPILE
6:    var n = null;      // DOES NOT COMPILE
7: }
=================
!!! NB:  var a = 2, b = 3;  // DOES NOT COMPILE
In other words, Java does not allow var in multiple variable declarations.
13: var n = "myData";
14: n = null;
15: var m = 4;
16: m = null;  // DOES NOT COMPILE
Line 14 compiles without issue because n is of type String, which is an object. On the other hand, line 16 does not compile since the type of m is a primitive int, which cannot be assigned a null value.
 var o = (String)null;
Since the type is provided, the compiler can apply type inference and set the type of the var to be String.
public int addition(var a, var b) {  // DOES NOT COMPILE
   return a + b;
}
In this example, a and b are method parameters. These are not local variables. 
Remember that var is only used for local variable type inference!
package var;
 
public class Var {
   public void var() {
      var var = "var";
   }
   public void Var() {
      Var var = new Var();
   }
}

There’s one last rule you should be aware of. While var is not a reserved word and allowed to be used as an identifier, it is considered a reserved type name. A reserved type name means it cannot be used to define a type, such as a class, interface, or enum. For example, the following code snippet does not compile because of the class name:


public class var {  // DOES NOT COMPILE
   public var() {
   }
}

Style Guidelines for Local Variable Type Inference in Java,” which is available at the following location. This resource includes great style suggestions.

https://openjdk.java.net/projects/amber/LVTIstyle.html





A var is used as a local variable in a constructor, method, or initializer block.

A var cannot be used in constructor parameters, method parameters, instance variables, or class variables.

A var is always initialized on the same line (or statement) where it is declared.

The value of a var can change, but the type cannot.

A var cannot be initialized with a null value without a type.

A var is not permitted in a multiple-variable declaration.

A var is a reserved type name but not a reserved word, meaning it can be used as an identifier except as a class, interface, or enum name.
=============
The piecesOfCheese variable is a method parameter and, as discussed earlier, it also acts like a local variable in terms of garbage collection and scope. Both of these variables are said to have a scope local to the method. This means they cannot be used outside of where they are defined.

Java code exists inside of a Java Virtual Machine (JVM), which includes numerous processes independent from your application code. One of the most important of those is a built-in garbage collector.
===============
All Java objects are stored in your program memory’s heap.The heap, which is also referred to as the free store, represents a large pool of unused memory allocated to your Java application. 
======================
public static void main(String[] args) {
   System.gc();
}

An object is no longer reachable when one of two situations occurs:

The object no longer has any references pointing to it.

All references to the object have gone out of scope.
An object will remain on the heap until it is no longer reachable


The reference is a variable that has a name and can be used to access the contents of an object. A reference can be assigned to another reference, passed to a method, or returned from a method. All references are the same size, no matter what their type is.

An object sits on the heap and does not have a name. Therefore, you have no way to access an object except through a reference. Objects come in all different shapes and sizes and consume varying amounts of memory. An object cannot be assigned to another object, and an object cannot be passed to a method or returned from a method. It is the object that gets garbage collected, not its reference.
==============
Option D is not valid because a period (.) is not allowed in identifiers.: java.lang
============
  1: public class WaterBottle {
  2:    private String brand;
  3:    private boolean empty;
  4:    public static float code;
  5:    public static void main(String[] args) {
  6:      WaterBottle wb = new WaterBottle();
  7:      System.out.println("Empty = " + wb.empty);
  8:      System.out.println("Brand = " + wb.brand);
  9:      System.out.println("Code = " + code);
  10:   } }
Line 8 generates a compiler error.

Line 9 generates a compiler error.

Empty =

Empty = false

Brand =

Brand = null

Code = 0.0

Code = 0f

Answer:
D, F, G. The code compiles and runs without issue, so options A and B are incorrect. A boolean field initializes to false, making option D correct with Empty = false being printed. Object references initialize to null, not the empty String, so option F is correct with Brand = null being printed. Finally, the default value of floating-point numbers is 0.0. Although float values can be declared with an f suffix, they are not printed with an f suffix. For these reasons, option G is correct and Code = 0.0 is printed.
============

!!! NB: var morning = ""; morning = null; // COMPILES
var night = new Object(); //compiles
---
3. The variable temp is declared as a float, but the assigned value is 50.0, which is a double without the F/f postfix.  float temp = 50.0;
 Since a double doesn’t fit inside a float, line 3 does not compile. In Java, double has more bits than float.

float is 32 bits.
-----
A local variable of type boolean defaults to null.: var doesn have a default!!!!

 long values default to 0L.
------------------
 In Java, there are no guarantees when garbage collection will run. 
An object may be eligible for garbage collection but never removed from the heap.
default values null and 0L,

 var is not a reserved word in Java and may be used as an identifier: String… var // legal

!! NB: A var cannot be used for a constructor or method parameter or for an instance or class variable,
==============

!! NB !!!
int amount = 0xE; (Hexadecimal integer, valid int)
int amount = 0b101; (Binary integer, valid int)
0b is the prefix for a binary value, and 0x is the prefix for a hexadecimal value. These values can be assigned to many primitive types, including int and double,

Line 4 does not compile because Java, unlike some other programming languages, does not support setting default method parameter values: void print(int length = 3) { // DOESNT compile
fins is in scope and accessible only inside the instance initializer on line 3: 
1: public class ClownFish {
  2:    int gills = 0, double weight=2;
  3:    { int fins = gills; }
  4:    void print(int length = 3) {
  5:       System.out.println(gills);
  6:       System.out.println(weight);
  7:       System.out.println(fins);
============================

a constructor argument is accessible only in the constructor itself, not for the life of the instance of the class.

Since char is an unsigned data type, it cannot be assigned a negative value: char bla = -1;
int bla = 1;: Outputs 1.
char bla = 1;: Outputs a control character (non-printable).
char bla = 42;: Outputs * (asterisk).
========================

Table 3.1: Order of operator precedence
Operator: top are strongest: 

Symbols and examples

Post-unary operators 			expression++, expression--

Pre-unary operators      		++expression, --expression

Other unary operators			-, !, ~, +, (type)

Multiplication/division/modulus		*, /, %

Addition/subtraction			+, -

Shift operators				<<, >>, >>>

Relational operators			<, >, <=, >=, instanceof

Equal to/not equal to			==, !=

Logical operators			&, ^, |

Short-circuit logical operators		&&, ||

Ternary operators			boolean expression ? expression1 : expression2

Assignment operators			=, +=, -=, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=

========================
unary operator is one that requires exactly one operand, or variable, to function. 
int pelican = !5;         // DOES NOT COMPILE
boolean penguin = -true;  // DOES NOT COMPILE
boolean peacock = !0;     // DOES NOT COMPILE

in Java, 1 and true are not related in any way, just as 0 and false are not related.
==============
short robin = 3 + [(4 * 2) + 4];      // DOES NOT COMPILE
 Java, unlike some other programming languages, does not allow brackets, [], to be used in place of parenthese
---------------
Numeric Promotion Rules
If two values have different data types, Java will automatically promote one of the values to the larger of the two data types.

If one of the values is integral and the other is floating-point, Java will automatically promote the integral value to the floating-point value’s data type.

Smaller data types, namely, byte, short, and char, are first promoted to int any time they’re used with a Java binary arithmetic operator, even if neither of the operands is int.

After all promotion has occurred and the operands have the same data type, the resulting value will have the same data type as its promoted operands.
--------------------
What is the data type of x + y?

double x = 39.21;
float y = 2.1;
var z = x + y;

This is actually a trick question, as this code will not compile!
============
What is the data type of x * y?

short x = 10;
short y = 3;
var z = x * y; INT;
------------
 it will throw a compiler exception if it detects that you are trying to convert from larger to smaller data types without casting. int herd = 1;
Spaces between the cast and the value are optional. 
float egg = 2.0 / 9;        // DOES NOT COMPILE
int tadpole = (int)5 * 2L;  // DOES NOT COMPILE
short frog = 3 - 2.0;       // DOES NOT COMPILE
All of these examples involve putting a larger value into a smaller data type.

int fish = 1.0;        // DOES NOT COMPILE
short bird = 1921222;  // DOES NOT COMPILE
int mammal = 9f;       // DOES NOT COMPILE
long reptile = 192301398193810323;  // DOES NOT COMPILE
 the last statement does not compile because Java interprets the literal as an int and notices that the value is larger than int allows. The literal would need a postfix L or l to be considered a long.

 casting primitives is required any time you are going from a larger numerical data type to a smaller numerical data type, or converting from a floating-point number to an integral value.


int trainer = (int)1.0;
short ticketTaker = (short)1921222;  // Stored as 20678
int usher = (int)9f;
long manager = 192301398193810323L;
The second value, 1,921,222, is too large to be stored as a short, so numeric overflow occurs and it becomes 20,678. Overflow is when a number is so large that it will no longer fit within the data type, so the system “wraps around” to the lowest negative value and counts up from there, similar to how modulus arithmetic works. There’s also an analogous underflow, when the number is too low to fit in the data type, such as storing -200 in a byte field.
System.out.print(2147483647+1);  // -2147483648
Since 2147483647 is the maximum int value, adding any strictly positive value to it will cause it to wrap to the smallest negative number.


short mouse = 10;
short hamster = 3;
short capybara = mouse * hamster;  // DOES NOT COMPILE auto converts short into int when *
short capybara = (short)(mouse * hamster);
hort values are automatically promoted to int when applying any arithmetic operator, with the resulting value being of type int. Trying to assign a short variable with an int value results in a compiler error, as Java thinks you are trying to implicitly convert from a larger data type to a smaller one.
short capybara = (short)mouse * hamster;      // DOES NOT COMPILE
short gerbil = 1 + (short)(mouse * hamster);  // DOES NOT COMPILE
In the second example, casting is performed successfully, but the resulting value is automatically promoted to int because it is used with the binary arithmetic operator (+).
long goat = 10;
int sheep = 5;
sheep = sheep * goat;   // DOES NOT COMPILE
sheep *= goat; // compiles
The compound operator will first cast sheep to a long, apply the multiplication of two long values, and then cast the result to an int. Unlike the previous example, in which the compiler reported an error, in this example we see that the compiler will automatically cast the resulting value to the data type of the value on the left side of the compound operator.
long wolf = 5;
long coyote = (wolf=3);
System.out.println(wolf);   // 3
System.out.println(coyote); // 3
The key here is that (wolf=3) does two things. First, it sets the value of the variable wolf to be 3. Second, it returns a value of the assignment, which is also 3.
boolean healthy = false;
if(healthy = true)
   System.out.print("Good!"); // it’s actually assigning healthy a value of true. compiles, prints: Good!

boolean bear = false;
boolean polar = (bear = true);
System.out.println(polar);  // true

File monday = new File("schedule.txt");
File tuesday = new File("schedule.txt");
File wednesday = tuesday;
System.out.println(monday == tuesday);    // false
System.out.println(tuesday == wednesday); // true
Even though all of the variables point to the same file information, only two references, tuesday and wednesday, are equal in terms of == since they point to the same object.

System.out.print(null == null);  // true

a instanceof b

Returns true if the reference that a points to is an instance of a class, subclass, or class that implements a particular interface, as named in b

public static void openZoo(Number time) {
   if(time instanceof Integer)
      System.out.print((Integer)time + " O'clock");
   else
      System.out.print(time);
}
t is common to use casting and instanceof together when working with objects that can be various different types, since it can give you access to fields available only in the more specific classes. It is considered a good coding practice to use the instanceof operator prior to casting from one object to a narrower type

One area the exam might try to trip you up on is using instanceof with incompatible types. For example, Number cannot possibly hold a String value, so the following would cause a compilation error:


public static void openZoo(Number time) {
   if(time instanceof String) // DOES NOT COMPILE
   ...
It gets even more complicated as the previous rule applies to classes, but not interfaces.

The instanceof check fails with incompatible classes (e.g., Number vs. String) because they can't relate, causing a compilation error. However, instanceof works with interfaces since a class can implement multiple interfaces, even if seemingly unrelated.

 you should know that calling instanceof on the null literal or a null reference always returns false.

System.out.print(null instanceof Object); // false
Object noObjectHere = null;
System.out.print(noObjectHere instanceof String); // false
System.out.print(null instanceof null);  // DOES NOT COMPILE

=====================
The logical operators, (&), (|), and (^), may be applied to both numeric and boolean data types;
& Logical AND is true only if both values are true.
| Inclusive OR is true if at least one of the values is true.
^ Exclusive XOR is true only if one value is true and the other is false
!! NB !! ^XOR(exclusive or): true if ONLY 1 VAL IS TRUE

Short-Circuit Operators: && || are nearly identical to the logical operators, & and |, except that the right side of the expression may never be evaluated if the final result can be determined by the left side of the expression

if(duck!=null & duck.getAge()<5) { // Could throw a NullPointerException: The issue is that the logical AND (&) operator evaluates both sides of the expression. 
   // Do something
}
if(duck!=null && duck.getAge()<5) {
   // Do something

int stripes = 7; 
System.out.print((stripes > 5) ? 21 : "Zebra"); // COMPILES
int animal = (stripes < 9) ? 3 : "Horse";  // DOES NOT COMPILE
Both expressions evaluate similar boolean values and return an int and a String, although only the first one will compile.
=================
Options B and C are both arithmetic operators and cannot be applied to a boolean value: + and --
you can cast a boolean variable since boolean is a type. (boolean)

 long ear = 10; i dont have here L: is ear long or int

ChatGPT said:
ChatGPT
ear is long. The L is optional when the value fits within an int range; Java treats it as long because it's declared as long.

in increasing order of precedence: +, *, %, --; 

!!! NB !!!   =, ?:, ||, &&, |, ^, &, ==, !=, <, <=, >, >=, instanceof, <<, >>, >>>, +, -, *, /, %, ++, --, !, ~, (), new, (type)


Line 5 increments pig by 1, but it returns the original value of 4 since it is using the post-increment operator. 
 4: int pig = (short)4;
  5: pig = pig++; /// still 4
  6: long goat = (int)2;
  7: goat -= 1.0;
  8: System.out.print(pig + " - " + goat);

pig = pig++; uses post-increment, so pig is incremented after its value is used. The original value (4) is assigned back to pig, not the incremented value.

To make pig equal to 5, use: pig = ++pig;
==========
does not compile due to an error on the second line.: Even though both height and weight are cast to byte, the multiplication operator automatically promotes them to int
resulting in an attempt to store an int in a short variable:
short height = 1, weight = 3;
  short zebra = (byte) weight * (byte) height;
  double ox = 1 + height * 2 + weight;
  long giraffe = 1 + 9 % height + 1;
  System.out.println(zebra);
  System.out.println(ox);
  System.out.println(giraffe);

int sample2 = 3 * 2 % 3; // first *(6) then % 3 = 0

The return value of an assignment operation expression is the value of the newly assigned variable.

Line 4 (float symphony = (float)((song == 1_000f) ? song * 2L : song);):

This line also compiles because the ternary operator evaluates to either a double or a long, both of which can be safely cast to a float.

short melody = (byte)(double)(note *= 2);

!! NB !! 
On line 6, we are incrementing one past the maximum byte value. Due to overflow, this will result in a negative number: start = (byte)(Byte.MAX_VALUE + 1);
START IN -128

UNARY OPERATOR IS: Unary operators operate on one operand:

+ (Positive)
- (Negate)
++ (Increment)
-- (Decrement)
! (Logical NOT)
~ (Bitwise NOT)
=========================

Remember that in Java, unlike some other programming languages, tabs are just whitespace and are not evaluated as part of the execution.

int hourOfDay = 1;
if(hourOfDay) {  // DOES NOT COMPILE
   ...
}

int month = 5;
 
switch month {  // DOES NOT COMPILE
   case 1: System.out.print("January");
}
 
switch (month)  // DOES NOT COMPILE
   case 1: System.out.print("January");
 
switch (month) {
   case 1: 2: System.out.print("January"); // DOES NOT COMPILE
}
 
switch (month) {
   case 1 || 2: System.out.print("January"); // DOES NOT COMPILE
}

 this statement is perfectly valid: switch (month) {}


!!! NB !!!
The following is a list of all data types supported by switch statements:
int and Integer
byte and Byte
short and Short
char and Character
String
enum values
var (if the type resolves to one of the preceding types)
Remember, boolean, long, float, double, and each of their associated wrapper classes are not supported by switch statements.
There is no requirement that the case or default statement be in a particular order, unless you are going to have pathways that reach multiple sections of the switch block in a single execution.

final int getCookies() { return 4; }
void feedAnimals() {
   final int bananas = 1;
   int apples = 2;
   int numberOfAnimals = 3;
   final int cookies = getCookies();
   switch (numberOfAnimals) {
      case bananas:
      case apples:  // DOES NOT COMPILES
      case getCookies():  // DOES NOT COMPILE
      case cookies :  // DOES NOT COMPILE
      case 3 * 5 :
   }
}

The bananas variable is marked final, and its value is known at compile-time, so it is valid. The apples variable is not marked final, even though its value is known, so it is not permitted. The next two case statements, with values getCookies() and cookies, do not compile because methods are not evaluated until runtime, so they cannot be used as the value of a case statement, even if one of the values is stored in a final variable. The last case statement, with value 3 * 5, does compile, as expressions are allowed as case values, provided the value can be resolved at compile-time. They also must be able to fit in the switch data type without an explicit cast

private int getSortOrder(String firstName, final String lastName) {
   String middleName = "Patricia";
   final String suffix = "JR";
   int id = 0;
   switch(firstName) {
      case "Test":
         return 52;
      case middleName:  // DOES NOT COMPILE
         id = 5;
         break;
      case suffix:
         id = 0;
         break;
      case lastName:    // DOES NOT COMPILE
         id = 8;
         break;
      case 5:           // DOES NOT COMPILE
         id = 7;
         break;
      case 'J':         // DOES NOT COMPILE
         id = 10;
         break;
      case java.time.DayOfWeek.SUNDAY:  // DOES NOT COMPILE
         id=15;
         break;
   }
   return id;
}

short size = 4;
final int small = 15;
final int big = 1_000_000;
switch(size) {
   case small:
   case 1+2 :
   case big:  // DOES NOT COMPILE
}
As you may recall from our discussion of numeric promotion and casting in Chapter 3, the compiler can easily cast small from int to short at compile-time because the value 15 is small enough to fit inside a short. This would not be permitted if small was not a compile-time constant. Likewise, it can convert the expression 1+2 from int to short at compile-time. On the other hand, 1_000_000 is too large to fit inside of short without an explicit cast, so the last case statement does not compile.

short: 16 bits, range -32,768 to 32,767.
int: 32 bits, range -2,147,483,648 to 2,147,483,647.

int lizard = 0;
do {
   lizard++;
} while(false);
System.out.println(lizard);  // 1
========================

In practice, infinite loops can be used to monitor processes that exist for the life of the program—for example, a process that wakes up every 30 seconds to look for work to be done and then goes back to sleep afterward. When creating an infinite loop like this, you need to make sure there are only a fixed number of them created by the application, or you could run out of memory. You also have to make sure that there is a way to stop them, often as part of the application shutting down. Finally, there are modern alternatives to creating infinite loops, such as using a scheduled thread executor,

=========================
for( ; ; )
   System.out.println("Hello World");
Although this for loop may look like it does not compile, it will in fact compile and run without issue. It is actually an infinite loop that will print the same statement repeatedly. This example reinforces the fact that the components of the for loop are each optional. Note that the semicolons separating the three sections are required, as for( ) without any semicolons will not compile.
===============================

int x = 0;
for(long y = 0, z = 4; x < 5 && y < 10; x++, y++) {
   System.out.print(y + " "); }
System.out.print(x + " "); // 0 1 2 3 4 5
=====

int x = 0;
for(int x = 4; x < 5; x++) {   // DOES NOT COMPILE
   System.out.print(x + " ");
}
// remove int in for()

The variables in the initialization block must all be of the same type. int x = 0;
for(long y = 0, int z = 4; x < 5; x++) {  // DOES NOT COMPILE
   System.out.print(y + " ");
}
================

public void printNames(String[] names) {
   for(String name : names)
      System.out.println(name);
}
==================

String[] names = new String[3];
for(int name : names) {  // DOES NOT COMPILE cause of the int and not String!!!
   System.out.print(name + " ");
}

============
int[][] myComplexArray = {{5,2,1,3},{3,9,8,9},{5,7,12,7}};
 
for(int[] mySimpleArray : myComplexArray) {
   for(int i=0; i<mySimpleArray.length; i++) {
      System.out.print(mySimpleArray[i]+"\t");
   }
   System.out.println();
}
========

int hungryHippopotamus = 8;
while(hungryHippopotamus>0) {
   do {
      hungryHippopotamus -= 2;
   } while (hungryHippopotamus>5);
   hungryHippopotamus--;
   System.out.print(hungryHippopotamus+", ");
} // 3,0

==============

A label is an optional pointer to the head of a statement that allows the application flow to jump to it or break from it. It is a single identifier that is proceeded by a colon (:). 

int[][] myComplexArray = {{5,2,1,3},{3,9,8,9},{5,7,12,7}};
 
OUTER_LOOP:  for(int[] mySimpleArray : myComplexArray) {
   INNER_LOOP:  for(int i=0; i<mySimpleArray.length; i++) {
      System.out.print(mySimpleArray[i]+"\t");
   }
   System.out.println();
}
======================

 Imagine we have a zookeeper who is supposed to clean the first leopard in each of four stables but skip stable b entirely.


1: public class CleaningSchedule {
2:    public static void main(String[] args) {
3:       CLEANING: for(char stables = 'a'; stables<='d'; stables++) {
4:          for(int leopard = 1; leopard<4; leopard++) {
5:             if(stables=='b' || leopard==2) {
6:                continue CLEANING;
7:             }
8:             System.out.println("Cleaning: "+stables+","+leopard);
9: } } } }
======================

One facet of break, continue, and return that you should be aware of is that any code placed immediately after them in the same block is considered unreachable and will not compile. For example, the following code snippet does not compile:


int checkDate = 0;
while(checkDate<10) {
   checkDate++;
   if(checkDate>100) {
      break;
      checkDate++;  // DOES NOT COMPILE
   }
}
====================
One thing to remember is that it does not matter if loop or decision structure actually visits the line of code. For example, the loop could execute zero or infinite times at runtime. Regardless of execution, the compiler will report an error if it finds any code it deems unreachable, in this case any statements immediately following a break, continue, or return statemen
===========
 	
Allows optional labels Allows break statement Allows continue statement

while

Yes

Yes

Yes

do while

Yes

Yes

Yes

for

Yes

Yes

Yes

switch

Yes

Yes

No
============
A for-each loop can be executed on any Collections object that implements java.lang.Iterable, such as List or Set, but not all Collections classes, such as Map, 

The conditional expression of for loops is evaluated at the start of the loop execution, meaning the for loop may execute zero or more times, making option C correct

a default statement is not required in a switch statement. 


int[] weather = {72, 75, 80, 68, 74};
        for (int i=0; i<=weather.length-1; ++i) {
            System.out.print("\nweather: " + weather[i]);
        } why here it doesnt start from weather[1]: we have ++i?

ChatGPT said:
ChatGPT
The reason the loop starts from weather[0] and not weather[1] is that the ++i is applied after the loop's body executes for the first time. The loop control statement i = 0; i <= weather.length - 1; ++i works as follows:

Initialization: int i = 0; sets i to 0.
Condition Check: The loop checks i <= weather.length - 1, which is true for i = 0.
Loop Body: It then executes System.out.print("\nweather: " + weather[i]);, so weather[0] is printed.
Increment: Finally, ++i increments i to 1 after the first iteration is complete.
The loop always starts with i = 0, regardless of the ++i increment, because the increment happens after the first iteration.

=================
!! NB !!  The first case statement does not compile, as continue cannot be used inside a switch statement
===========
 for(var sophia : olivia) {
     System.out.println(sophia);
  } can use Set, []int but NOT String and STringBuilder(can in for int i loop)
=================
CHAPTER 5: apis 
In the context of an Application Programming Interface (API),
an interface refers to a group of classes or Java interface definitions giving you access to a service or functionality.
String name = "Fluffy";
String name = new String("Fluffy"); he String class is special and doesn’t need to be instantiated
with new. String is a sequence of characters,implements the interface CharSequence. This interface is a general way of representing
several classes, including String and StringBuilder. If either operand is a String, + means concatenation
System.out.println("a" + "b" + 3); // ab3
System.out.println(1 + 2 + "c"); // 3c
System.out.println("c" + 1 + 2); // c12
!! NB !! Once a String object is created, it is not allowed to change. It cannot be made larger or
smaller, and you cannot change one of the characters inside it.Immutable has only a getter. There’s no way to change the value of s once it’s set.
Mutable has a setter. Note that even though the String class is immutable, it can still be used in
a mutable classAlso, immutable classes in Java are final, which prevents subclasses creation. You
wouldn’t want a subclass adding mutable behavior.

which isn’t used much on real projects but is great for tricking people on the exam.
What does this print out?
String s1 = "1";
String s2 = s1.concat("2");
s2.concat("3");
System.out.println(s2);
Did you say "12"? Good. The trick is to see if you forget that the String class is immutable by throwing a method call at you.

String string = "animals";
System.out.println(string.charAt(0)); // a
System.out.println(string.charAt(6)); // s
System.out.println(string.charAt(7)); // throws exception java.lang.StringIndexOutOfBoundsException: String index out of range: 7
System.out.println("abc".equals("ABC")); // false
System.out.println("ABC".equals("ABC")); // true
System.out.println("abc".equalsIgnoreCase("ABC")); // true

int indexOf(int ch)
int indexOf(int ch, int fromIndex)
int indexOf(String str)
int indexOf(String str, int fromIndex)
The following code shows how to use indexOf():
String string = "animals";
System.out.println(string.indexOf('a')); // 0
System.out.println(string.indexOf("al")); // 4
System.out.println(string.indexOf('a', 4)); // 4
System.out.println(string.indexOf("al", 5)); // -1

System.out.println(string.substring(string.indexOf('m'))); // mals
System.out.println(string.substring(3, 4)); // m
System.out.println(string.substring(3, 7)); // mals
System.out.println("Abc123".toLowerCase()); // abc123

System.out.println(string.substring(3, 3)); // empty string
System.out.println(string.substring(3, 2)); // throws exception
System.out.println(string.substring(3, 8)); // throws exception

Unlike charAt(), the indexOf() doesn’t throw an exception if it can’t find a match. indexOf() returns –1 when no
match is found

System.out.println("abc".startsWith("a")); // true
System.out.println("abc".startsWith("A")); // false
System.out.println("abc".endsWith("c")); // true
System.out.println("abc".endsWith("a")); // false

String replace(char oldChar, char newChar)
String replace(CharSequence target, CharSequence replacement)
System.out.println("abcabc".replace('a', 'A')); // AbcAbc
 System.out.println("abcabc".replace("a", "A")); // AbcAbc

boolean contains(CharSequence charSeq)
 System.out.println("abc".contains("b")); // true
 System.out.println("abc".contains("B")); // false 
System.out.println("abc".contains("b")); // true
 System.out.println("abc".contains("B")); // false 

trim(), strip(), stripLeading(), and stripTrailing()
The strip() and trim()methods remove whitespace from the beginning and end of a String . whitespace consists of spaces along with the \t (tab) and \n (newline) characters. Other characters, such as \r (carriage return), are also included in what gets trimmed.
The strip() method is new in Java 11. It does everything that trim() does, but it supports
Unicode.
  
 You don’t need to know about Unicode for the exam. But if you want to test
the difference, one of Unicode whitespace characters is as follows:
 char ch = '\u2000';
 Additionally, the stripLeading() and stripTrailing() methods were added in Java
11. The stripLeading() method removes whitespace from the beginning of the String and
leaves it at the end. The stripTrailing() method does the opposite. It removes whitespace
from the end of the String and leaves it at the beginning.
 The method signatures are as follows:
 String strip()
 String stripLeading()
 String stripTrailing()
 String trim() 

both trim() and strip() leave the same three characters "abc" because they remove both
the leading and trailing whitespace. 

String text = " abc\t ";
System.out.println(text.trim().length()); // 3
System.out.println(text.strip().length()); // 3
System.out.println(text.stripLeading().length()); // 5
System.out.println(text.stripTrailing().length());// 4

intern()
The intern() method returns the value from the string pool if it is there. Otherwise, it
adds the value to the string pool. 
String result = "AniMaL ".trim().toLowerCase().replace('a', 'A');
System.out.println(result); // AnimAl: really? waht abt replaceAll?? pretty sure

10: String alpha = "";
11: for(char current = 'a'; current <= 'z'; current++)
12: alpha += current;
13: System.out.println(alpha);
The empty String on line 10 is instantiated, and then line 12 appends an "a". However,
because the String object is immutable, a new String object is assigned to alpha, and the
"" object becomes eligible for garbage collection. The next time through the loop, alpha
is assigned a new String object, "ab", and the "a" object becomes eligible for garbage collection. The next iteration assigns alpha to "abc", and the "ab" object becomes eligible for
garbage collection, and so on.
This sequence of events continues, and after 26 iterations through the loop, a total of 27
objects are instantiated, most of which are immediately eligible for garbage collection

4: StringBuilder sb = new StringBuilder("start");
5: sb.append("+middle"); // sb = "start+middle"
6: StringBuilder same = sb.append("+end"); // "start+middle+end"

4: StringBuilder a = new StringBuilder("abc");
5: StringBuilder b = a.append("de");
6: b = b.append("f").append("g");
7: System.out.println("a=" + a);
8: System.out.println("b=" + b);
Did you say both print "abcdefg"? Good. There’s only one StringBuilder object
here. We know that because new StringBuilder() was called only once. On line 5, there
are two variables referring to that object, which has a value of "abcde". On line 6, those
two variables are still referring to that same object, which now has a value of "abcdefg".
Incidentally, the assignment back to b does absolutely nothing. b is already pointing to that
StringBuilder

StringBuilder sb1 = new StringBuilder();
StringBuilder sb2 = new StringBuilder("animal");
StringBuilder sb3 = new StringBuilder(10);

StringBuilder sb = new StringBuilder("animals");
String sub = sb.substring(sb.indexOf("a"), sb.indexOf("al"));
int len = sb.length();
char ch = sb.charAt(6);
System.out.println(sub + " " + len + " " + ch);
The correct answer is anim 7 s. T

There are more than 10 method signatures that look similar but that take different data types as parameters. All those methods
are provided so you can write code like this:
StringBuilder sb = new StringBuilder().append(1).append('c');
sb.append("-").append(true);
System.out.println(sb); // 1c-true

StringBuilder insert(int offset, String str)

3: StringBuilder sb = new StringBuilder("animals");
4: sb.insert(7, "-"); // sb = animals
5: sb.insert(0, "-"); // sb = -animals
6: sb.insert(4, "-"); // sb = -ani-mals

StringBuilder delete(int startIndex, int endIndex)
StringBuilder deleteCharAt(int index)
StringBuilder sb = new StringBuilder("abcdef");
sb.delete(1, 3); // sb = adef
sb.deleteCharAt(5); // throws an exception

If you specify a second parameter that is past the end of the StringBuilder, Java will just
assume you meant the end. That means this code is legal:
StringBuilder sb = new StringBuilder("abcdef");
sb.delete(1, 100); // sb = a

The replace() method works differently for StringBuilder than it did for String. The
method signature is as follows:
StringBuilder replace(int startIndex, int endIndex, String newString)

StringBuilder builder = new StringBuilder("pigeon dirty");
builder.replace(3, 6, "sty");
System.out.println(builder); // pigsty dirty
First, Java deletes the characters starting with index 3 and ending right before index 6.
This gives us pig dirty. Then Java inserts to the value "sty" in that position

StringBuilder builder = new StringBuilder("pigeon dirty");
builder.replace(3, 100, "");
System.out.println(builder);
It actually prints "pig". 

StringBuilder sb = new StringBuilder("ABC");
sb.reverse();
System.out.println(sb);
As expected, this prints CBA.

StringBuilder one = new StringBuilder();
StringBuilder two = new StringBuilder();
StringBuilder three = one.append("a");
System.out.println(one == two); // false
System.out.println(one == three); // true

You saw earlier that you can say you want logical equality rather than object equality
for String objects:
String x = "Hello World";
String z = " Hello World".trim();
System.out.println(x.equals(z)); // true

This works because the authors of the String class implemented a standard method
called equals to check the values inside the String rather than the string reference itself

the authors of StringBuilder did not implement equals(). 
the authors of StringBuilder did not implement equals().
If you call equals() on two StringBuilder instances, it will check reference equality. You
can call toString() on StringBuilder to get a String to check for equality instead.

1: public class Tiger {
2: String name;
3: public static void main(String[] args) {
4: Tiger t1 = new Tiger();
5: Tiger t2 = new Tiger();
6: Tiger t3 = t1;
7: System.out.println(t1 == t3); // true
8: System.out.println(t1 == t2); // false
9: System.out.println(t1.equals(t2)); // false
10: } }
The first two statements check object reference equality. Line 7 prints true because we
are comparing references to the same object. Line 8 prints false because the two object references are different. Line 9 prints false since Tiger does not implement equals().

1: public class Tiger {
2: String name;
3: public static void main(String[] args) {
4: Tiger t1 = new Tiger();
5: Tiger t2 = new Tiger();
6: Tiger t3 = t1;
7: System.out.println(t1 == t3); // true
8: System.out.println(t1 == t2); // false
9: System.out.println(t1.equals(t2)); // false
10: } }
The first two statements check object reference equality. Line 7 prints true because we
are comparing references to the same object. Line 8 prints false because the two object references are different. Line 9 prints false since Tiger does not implement equals().

Since strings are everywhere in Java, they use up a lot of memory. In some production
applications, they can use a large amount of memory in the entire program. Java realizes
that many strings repeat in the program and solves this issue by reusing common ones. The
string pool, also known as the intern pool, is a location in the Java virtual machine (JVM)
that collects all these strings.
The string pool contains literal values and constants that appear in your program. For
example, "name" is a literal and therefore goes into the string pool. myObject.toString() is
a string but not a literal, so it does not go into the string pool.

String x = "Hello World";
String y = "Hello World";
System.out.println(x == y); // true

Remember that Strings are immutable and literals are pooled. The JVM created only
one literal in memory. x and y both point to the same location in memory; therefore, the
statement outputs true. It gets even trickier. Consider this code:

String x = "Hello World";
String z = " Hello World".trim();
System.out.println(x == z); // false
In this example, we don’t have two of the same String literal. Although x and z happen to evaluate to the same string, one is computed at runtime. Since it isn’t the same at
compile-time, a new String object is created.

String singleString = "hello world";
String oneLine = "hello " + "world";
String concat = " hello";
concat += "world";
System.out.println(singleString == oneLine);  // false
System.out.println(singleString == concat); // false
String x = "Hello World";
String y = new String("Hello World");
System.out.println(x == y); // false

You can also do the opposite and tell Java to use the string pool. The intern() method
will use an object in the string pool if one is present. If the literal is not yet in the string
pool, Java will add it at this time.
 String name = "Hello World";
 String name2 = new String("Hello World").intern();
 System.out.println(name == name2); // true 


 15: String first = "rat" + 1;
 16: String second = "r" + "a" + "t" + "1";
 17: String third = "r" + "a" + "t" + new String("1");
 18: System.out.println(first == second); // true
 19: System.out.println(first == second.intern()); // true
 20: System.out.println(first == third); // false
 21: System.out.println(first == third.intern()); // true

 Remember to never use intern() or == to compare String objects in your
code. The only time you should have to deal with these is on the exam.

 Up to now, we’ve been referring to the String and StringBuilder classes as a “sequence of
characters.” This is true. They are implemented using an array of characters. An array is an
area of memory on the heap with space for a designated number of elements.

==========
StringBuilder one = new StringBuilder();
StringBuilder two = new StringBuilder();
StringBuilder three = one.append("a");
System.out.println(one == two); // false
System.out.println(one == three); // true

String x = "Hello World";
String z = " Hello World".trim();
System.out.println(x.equals(z)); // true

String x = "Hello World";
String z = " Hello World".trim();
System.out.println(x == z); // false

1:  public class Tiger {
2:     String name;
3:     public static void main(String[] args) {
4:        Tiger t1 = new Tiger();
5:        Tiger t2 = new Tiger();
6:        Tiger t3 = t1;
7:        System.out.println(t1 == t3);      // true
8:        System.out.println(t1 == t2);      // false
9:        System.out.println(t1.equals(t2)); // false
10: } }
 Line 9 prints false since Tiger does not implement equals()


String string = "a";
StringBuilder builder = new StringBuilder("a");
System.out.println(string == builder); //DOES NOT COMPILE

public class ArrayType {
   public static void main(String args[]) {
      String [] bugs = { "cricket", "beetle", "ladybug" };
      String [] alias = bugs;
      System.out.println(bugs.equals(alias));     // true
      System.out.println(
         bugs.toString()); //[Ljava.lang.String;@160bc7c0
} }


3: String[] strings = { "stringValue" };
4: Object[] objects = strings;
5: String[] againStrings = (String[]) objects;
6: againStrings[0] = new StringBuilder();   // DOES NOT COMPILE
7: objects[0] = new StringBuilder();        // careful!

7: We have a String[] referred to from an Object[] variable. At runtime, the code throws an ArrayStoreException. 



4: String[] mammals = {"monkey", "chimp", "donkey"};
5: System.out.println(mammals.length);           // 3
6: System.out.println(mammals[0]);               // monkey

Arrays .toString(numbers) instead of using the loop. That would have output [1, 6, 9]

!! NB !!
Java also provides a convenient way to search—but only if the array is already sorted.
Target element not found in sorted array:Negative value showing one smaller than the negative of the index, where a match needs to be inserted to preserve sorted order

3: int[] numbers = {2,4,6,8};
4: System.out.println(Arrays.binarySearch(numbers, 2)); // 0
5: System.out.println(Arrays.binarySearch(numbers, 4)); // 1
6: System.out.println(Arrays.binarySearch(numbers, 1)); // -1
7: System.out.println(Arrays.binarySearch(numbers, 3)); // -2
8: System.out.println(Arrays.binarySearch(numbers, 9)); // -5


=====================
ARRAY
==============
int[] numbers1 = new int[3];
When you use this form to instantiate an array, all elements are set to the default value
for that type.
int[] numbers2 = new int[] {42, 55, 99};

int[] numAnimals;
int [] numAnimals2;
int []numAnimals3;
int numAnimals4[];
int numAnimals5 []; // ALL DO THE SAME

int ids[], types;
 All we did was move the brackets, but it changed the behavior. This time we get one
variable of type int[] and one variable of type int .

5: int[] numbers = new int[] {3,2,1};
6: System.out.println(Arrays.binarySearch(numbers, 2));
7: System.out.println(Arrays.binarySearch(numbers, 3));
Note that on line 5, the array isn’t sorted. This means the output will not be predictable. When testing this example, line 6 correctly gave 1 as the output. However, line 7 gave the wrong answer. The exam creators will not expect you to know what incorrect values come out. As soon as you see the array isn’t sorted, look for an answer choice about unpredictable output.

compare() A negative number means the first array is smaller than the second.

A zero means the arrays are equal.

A positive number means the first array is larger than the second.
System.out.println(Arrays.compare(new int[] {1}, new int[] {2})); // returns -1 because 1 is less than 2.

how to compare arrays of different lengths:

If both arrays are the same length and have the same values in each spot in the same order, return zero.

If all the elements are the same but the second array has extra elements at the end, return a negative number.

If all the elements are the same but the first array has extra elements at the end, return a positive number.

If the first element that differs is smaller in the first array, return a negative number.

If the first element that differs is larger in the first array, return a positive number.

null is smaller than any other value.

For numbers, normal numeric order applies.

For strings, one is smaller if it is a prefix of another.

For strings/characters, numbers are smaller than letters.

For strings/characters, uppercase is smaller than lowercase.

System.out.println(Arrays.compare(
   new int[] {1}, new String[] {"a"})); // DOES NOT COMPILE: must be same type


The Arrays.mismatch() method compares two arrays element by element to find the first position where they differ.

Return Value:

If the arrays are identical (no mismatch), it returns -1.
If the arrays differ, it returns the index of the first mismatch.
If one array is a prefix of the other, the method returns the length of the shorter array.

System.out.println(Arrays.mismatch(new int[] {1}, new int[] {1})); // -1
System.out.println(Arrays.mismatch(new String[] {"a"}, new String[] {"A"})); // 0
System.out.println(Arrays.mismatch(new int[] {1, 2}, new int[] {1})); // 1
==================

VARARGS
==================
public static void main(String[] args)
public static void main(String args[])
public static void main(String... args) // varargs

int[][] vars1;          // 2D array
int vars2 [][];         // 2D array
int[] vars3[];          // 2D array
int[] vars4 [], space [][];  // a 2D AND a 3D array

String [][] rectangle = new String[3][2];

for (int[] inner : twoD) {
   for (int num : inner)
      System.out.print(num + " ");
   System.out.println();
}


==============
ARRAYLIST
============
An array has one glaring shortcoming: You have to know how many elements will be in the array when you create it, and then you are stuck with that choice. Just like a StringBuilder, an ArrayList can change capacity at runtime as needed. Like an array, an ArrayList is an ordered sequence that allows duplicates.
ArrayList list1 = new ArrayList();
ArrayList list2 = new ArrayList(10);
ArrayList list3 = new ArrayList(list2);

Java 5 introduced generics, which allow you to specify the type of class that the ArrayList will contain.


ArrayList<String> list4 = new ArrayList<String>();
ArrayList<String> list5 = new ArrayList<>();
var strings = new ArrayList<String>();
strings.add("a");
for (String s: strings) {  }

var list = new ArrayList<>();
list.add("a");
for (String s: list) { } // DOES NOT COMPILE
The type of var is ArrayList<Object>. Since there isn’t a type in the diamond operator, Java has to assume the most generic option it can. Therefore, it picks Object, the ultimate superclass. Adding a String to the list is fine. You can add any subclass of Object. However, in the loop, we need to use the Object type rather than String.

ArrayList implements an interface called List.you can store an ArrayList in a List reference variable but not vice versa.
List<String> list6 = new ArrayList<>();
ArrayList<String> list7 = new List<>(); // DOES NOT COMPILE
 E is used by convention in generics to mean “any class that this array can hold.” If you didn’t specify a type when creating the ArrayList, E means Object. Otherwise, it means the class you put between < and >.

boolean add(E element)
void add(int index, E element)
 It always returns true. As we’ll see later in the chapter, it is there because other classes in the Collections family need a return value in the signature when adding an element.
ArrayList list = new ArrayList();
list.add("hawk");          // [hawk]
list.add(Boolean.TRUE);    // [hawk, true]
System.out.println(list);  // [hawk, true]

ArrayList<String> safer = new ArrayList<>();
safer.add("sparrow");
safer.add(Boolean.TRUE);    // DOES NOT COMPILE

4: List<String> birds = new ArrayList<>();
5: birds.add("hawk");            // [hawk]
6: birds.add(1, "robin");        // [hawk, robin]
7: birds.add(0, "blue jay");     // [blue jay, hawk, robin]
8: birds.add(1, "cardinal");     // [blue jay, cardinal, hawk, robin]
9: System.out.println(birds);    // [blue jay, cardinal, hawk, robin]

remove the first matching value in the ArrayList or remove the element at a specified index. The method signatures are as follows:
boolean remove(Object object)
E remove(int index)

boolean remove(Object object)
E remove(int index)
3: List<String> birds = new ArrayList<>();
4: birds.add("hawk");     // [hawk]
5: birds.add("hawk");     // [hawk, hawk]
6: System.out.println(birds.remove("cardinal")); // prints false
7: System.out.println(birds.remove("hawk"));     // prints true
8: System.out.println(birds.remove(0));          // prints hawk
9: System.out.println(birds);                    // []
 birds.remove(100) throws an IndexOutOfBoundsException.

E set(int index, E newElement)
The E return type is the element that got replaced. The following shows how to use this method:
15: List<String> birds = new ArrayList<>();
16: birds.add("hawk");                    // [hawk]
17: System.out.println(birds.size());     // 1
18: birds.set(0, "robin");               // [robin]
19: System.out.println(birds.size());     // 1
20: birds.set(1, "robin");               // IndexOutOfBoundsException

The ArrayList.set() method in Java is used to replace an element at a specific position in an ArrayList with a new element.

boolean isEmpty()
int size()

 There is no modifier that can prevent a default method from being overridden in a class implementing an interface

List<String> birds = new ArrayList<>();
System.out.println(birds.isEmpty());     // true
System.out.println(birds.size());        // 0
birds.add("hawk");                       // [hawk]
birds.add("hawk");                       // [hawk, hawk]
System.out.println(birds.isEmpty());     // false
System.out.println(birds.size());        // 2

void clear()
List<String> birds = new ArrayList<>();
birds.add("hawk");                    // [hawk]
birds.add("hawk");                    // [hawk, hawk]
System.out.println(birds.isEmpty());  // false
System.out.println(birds.size());     // 2
birds.clear();                        // []
System.out.println(birds.isEmpty());  // true
System.out.println(birds.size());     // 0
After we call clear(), birds is back to being an empty ArrayList of size 0.

boolean contains(Object object)
List<String> birds = new ArrayList<>();
birds.add("hawk");                           // [hawk]
System.out.println(birds.contains("hawk"));  // true
System.out.println(birds.contains("robin")); // false

31: List<String> one = new ArrayList<>();
32: List<String> two = new ArrayList<>();
33: System.out.println(one.equals(two));  // true
34: one.add("a");                         // [a]
35: System.out.println(one.equals(two));  // false
36: two.add("a");                         // [a]
37: System.out.println(one.equals(two));  // true
38: one.add("b");                         // [a,b]
39: two.add(0, "b");                      // [b,a]
40: System.out.println(one.equals(two));  // false

The parse methods, such as parseInt(), return a primitive, and the valueOf() method returns a wrapper class

int primitive = Integer.parseInt("123"); // String to int primitive
Integer wrapper = Integer.valueOf("123"); // String to Integer

you can just type the primitive value, and Java will convert it to the relevant wrapper class for you. This is called autoboxing

3: List<Integer> weights = new ArrayList<>();
4: Integer w = 50;
5: weights.add(w);                  // [50]
6: weights.add(Integer.valueOf(60));     // [50, 60]
7: weights.remove(new Integer(50)); // [60]
8: double first = weights.get(0);   // 60.0

3: List<Integer> heights = new ArrayList<>();
4: heights.add(null);
5: int h = heights.get(0);          // NullPointerException

calling any method on null gives a NullPointerException

13: List<String> list = new ArrayList<>();
14: list.add("hawk");
15: list.add("robin");
16: Object[] objectArray = list.toArray();

17: String[] stringArray = list.toArray(new String[0]); // convert a List<String> to a String[] array.
18: list.clear();
19: System.out.println(objectArray.length);     // 2
20: System.out.println(stringArray.length);     // 2

20: String[] array = { "hawk", "robin" };     // [hawk, robin]
21: List<String> list = Arrays.asList(array); // returns fixed size list
22: System.out.println(list.size());         // 2
23: list.set(1, "test");                     // [hawk, test]
24: array[0] = "new";                        // [new, test]
25: System.out.print(Arrays.toString(array));// [new, test]
26: list.remove(1);     // throws UnsupportedOperationException

32: String[] array = { "hawk", "robin" };        // [hawk, robin]
33: List<String> list = List.of(array);      // returns immutable list
34: System.out.println(list.size());            // 2
35: array[0] = "new";                          
36: System.out.println(Arrays.toString(array)); // [new, robin]
37: System.out.println(list);                   // [hawk, robin]
38: list.set(1, "test");      // throws UnsupportedOperationException


List<String> list1 = Arrays.asList("one", "two");
List<String> list2 = List.of("one", "two");
Both of these methods take varargs, which let you pass in an array or just type out the String values. This is handy when testing because you can easily create and populate a List on one line. Both methods create fixed-size arrays. If you will need to later add or remove elements, you’ll still need to create an ArrayList using the constructor

                                                                                     toArray()    Arrays.asList()             List.of()

Type converting from                                                                   List         Array (or varargs)           Array (or varargs)

Type created                                                                           Array              List                       List

Allowed to remove values from created object                                             No                No                           No

Allowed to change values in the created object                                        	Yes               Yes                        No

Changing values in the created object affects the original or vice versa.                No              Yes                         N/A


List<String> fixedSizeList  = Arrays.asList("a", "b", "c");
List<String> expandableList = new ArrayList<>(fixedSizeList);

 List<Integer> numbers = new ArrayList<>();
        numbers.add(99);
        numbers.add(5);
        numbers.add(1);
        numbers.add(12);
        Collections.sort(numbers);
        System.out.println(numbers); // [1, 5, 12, 99]

===============
SETS
=================
A Set is a collection of objects that cannot contain duplicates. If you try to add a duplicate to a set, the API will not fulfill the request. you cannot call set(index, value) or remove(index).
 ArrayList in Java is ordered by default. This means that the elements in an ArrayList are stored in the order in which they were added, and they are retrieved in the same order.
boolean return value on add() that always returned true for an ArrayList? Set is a reason it needs to exist. When trying to add a duplicate value, the method returns false and does not add the value.
3: Set<Integer> set = new HashSet<>();
4: System.out.println(set.add(66)); // true
5: System.out.println(set.add(66)); // false
6: System.out.println(set.size()); // 1
7: set.remove(66);
8: System.out.println(set.isEmpty()); // true

The most common implementation of Map is HashMap. Some of the methods are the same as those in ArrayList like clear(), isEmpty(), and size().

Table 5.7: Common Map methods
Method

Description

V get(Object key)

Returns the value mapped by key or null if none is mapped

V getOrDefault(Object key, V other)

Returns the value mapped by key or other if none is mapped

V put(K key, V value)

Adds or replaces key/value pair. Returns previous value or null

V remove(Object key)

Removes and returns value mapped to key. Returns null if none

boolean containsKey(Object key)

Returns whether key is in map

boolean containsValue(Object value)

Returns whether value is in map

Set<K> keySet()

Returns set of all keys

Collection<V> values()

Returns Collection of all values

8:  Map<String, String> map = new HashMap<>();
9:  map.put("koala", "bamboo");
10: String food = map.get("koala"); // bamboo
11: String other = map.getOrDefault("ant", "leaf"); // leaf
12: for (String key: map.keySet())
13:    System.out.println(key + " " + map.get(key)); // koala bamboo

The min() and max() methods compare two values and return one of them.

The method signatures for min() are as follows:


double min(double a, double b)
float min(float a, float b)
int min(int a, int b)
long min(long a, long b)
//There are four overloaded methods, s
long round(double num)
int round(float num)

long low = Math.round(123.45); // 123
long high = Math.round(123.50); // 124
int fromFloat = Math.round(123.45f); // 123

double pow(double number, double exponent)
double squared = Math.pow(5, 2); // 25.0
The random() method returns a value greater than or equal to 0 and less than 1. 
double num = Math.random();
. Arrays.binarySearch() searches a sorted array and returns the index of a match. If no match is found, it negates the position where the element would need to be inserted and subtracts 1

Although an ArrayList is not allowed to contain primitives, Java will autobox parameters passed in to the proper wrapper type. Collections.sort() sorts an ArrayList.


"Hello" is a string literal and is stored in the string pool.
s also refers to "Hello", so this condition is true.
   8: if ("Hello" == s) System.out.println("four");

"Hello".intern() returns the reference to the string "Hello" from the string pool.
t is a separate object created with new String(s), so this condition is false.
  3: var s = "Hello";
  4: var t = new String(s);
  5: if ("Hello".equals(s)) System.out.println("one");
  6: if (t == s) System.out.println("two");
  7: if (t.intern() == s) System.out.println("three");
  8: if ("Hello" == s) System.out.println("four");
  9: if ("Hello".intern() == t) System.out.println("five");

!! NB !!  Java does not allow you to compare String and StringBuilder using ==.
  13: String s1 = "java";
  14: String s2 = "java";
  15: StringBuilder s3 = new StringBuilder("java");
if (s1 == s3) count++;

int[] numbers = {1, 2, 3, 4};
int size = numbers.length; // size is 4
String text = "Hello";
int length = text.length(); // length is 5

  var string = "12345";
  var builder = new StringBuilder("12345"); RETURNS 5:
builder.charAt(4)
builder.replace(2, 4, "6").charAt(3)

 System.out.println(bla.substring(7, 7)); // ""

!!!! NB !!! A String concatenated with any other type gives a String.

String s1 = "purr";
  15: String s2 = "";
  22: s2 += 2;
  23: s2 += 'c';
  24: s2 += false;
  25:
  26: if ( s2 == "2cfalse") System.out.println("==");
  27: if ( s2.equals("2cfalse")) System.out.println("equals");

 StringBuilder b = "rumble"; // does not compile because you cannot assign a String to a StringBuilder
  b.append(4).deleteCharAt(3).delete(3, b.length() - 1);
  System.out.println(b);



Although it is legal to leave out the size for later dimensions of a multidimensional array, the first one is required. Option A declares a legal 2D array. Option B declares a legal 3D array. Option D declares a legal 2D array. 

int[][] scores = new int[5][];

Object[][][] cubbies = new Object[3][0][5];

String beans[] = new beans[6]; // NO TYPES beans

java.util.Date[] dates[] = new java.util.Date[2][];

int[][] types = new int[]; // no size: doesnt compoie

int[][] java = new int[][]; // no size declared in first arr: no compile


Arrays define a property called length. It is not a method, The ArrayList class defines a method called size()
: char[]c = new char[2];
  7: ArrayList l = new ArrayList();
  8: int length = __________ + _____________;

c.length

c.length()

c.size

c.size()

l.length

l.length()

l.size

l.size()

. An array is not able to change size, making option A correct and option B incorrect. Neither is immutable, making options C and D incorrect. The elements can change in value. An array does not override equals(), so it uses object equality, making option E incorrect. ArrayList does override equals() and defines it as the same elements in the same order, making option F correct.

Which of the following are true? (Choose all that apply.)

An array has a fixed size.

An ArrayList has a fixed size.

An array is immutable.

An ArrayList is immutable.

Calling equals() on two equivalent arrays returns true.

Calling equals() on two equivalent ArrayList objects returns true.

If you call remove(0) using an empty ArrayList object, it will compile successfully.

If you call remove(0) using an empty ArrayList object, it will run successfully.

Answer:
A, F, G. An array is not able to change size, making option A correct and option B incorrect. Neither is immutable, making options C and D incorrect. The elements can change in value. An array does not override equals(), so it uses object equality, making option E incorrect. ArrayList does override equals() and defines it as the same elements in the same order, making option F correct.

The compiler does not know when an index is out of bounds and thus can’t give you a compiler error, making option G correct. The code will throw an exception at runtime, though, making option H the final incorrect answer.



Definition: An Array is a fixed-size data structure that stores elements of the same type. Arrays in Java are objects that can store multiple values in a single variable.
// Declaring and initializing an array of integers
int[] numbers = {1, 2, 3, 4, 5};
// Creating an array with a specific size
int[] moreNumbers = new int[5];
// Accessing the first element
int firstNumber = numbers[0];  // Outputs 1

// Modifying an element
numbers[1] = 10;  // Now the array is [1, 10, 3, 4, 5]

Definition: A List is a part of the Java Collections Framework and represents an ordered collection (also known as a sequence). Unlike arrays, lists are dynamic, meaning their size can grow or shrink as needed.

Common Implementation: ArrayList is a commonly used class that implements the List interface.
// Creating an ArrayList of integers
List<Integer> numbers = new ArrayList<>();

// Adding elements to the list
numbers.add(1);
numbers.add(2);
numbers.add(3);
int firstNumber = numbers.get(0);  // Outputs 1
numbers.set(1, 10);  // Now the list is [1, 10, 3]
Rich set of methods: Provides many useful methods like add, remove, set, get, etc.
Part of Java's Collections Framework: Integrates well with other collection types (like Set and Map).

!! NB !!
List<Integer> list = Arrays.asList(10, 4, -1, 5, 8, 2);
Collections.sort(list);  // Sorted list: [-1, 2, 4, 5, 8, 10]
Integer converted[] = list.toArray(new Integer[4]);
System.out.println(Arrays.toString(converted));  // Outputs: [-1, 2, 4, 5, 8, 10]


 System.out.println(Arrays.binarySearch(array, 12));
 an array must be sorted for binarySearch() to return a meaningful result. Option F is correct because line 14 prints a number, but the behavior is undefined

  23: double one = Math.pow(1, 2);
  24: int two = Math.round(1.0);
  25: float three = Math.random();
  26: var doubles = new double[] { one, two, three};
  27:
  28: String [] names = {"Tom", "Dick", "Harry"};
  29: List<String> list = names.asList();
  30: var other = Arrays.asList(names);
  31: other.set(0, "Sue");
Line 23

Line 24

Line 25

Line 26

Line 29

Line 30

Line 31

Answer:
B, C, E. Remember to watch return types on math operations. One of the tricks is option B on line 24. The round() method returns an int when called with a float. However, we are calling it with a double so it returns a long. The other trick is option C on line 25. The random() method returns a double. Converting from an array to an ArrayList uses Arrays.asList(names). There is no asList() method on an array instance,

After sorting, hex contains [30, 3A, 8, FF]. Remember that numbers sort before letters, and strings sort alphabetically. This makes 30 come before 8. A binary search correctly finds 8 at index 2 and 3A at index 1. It cannot find 4F but notices it should be at index 2. The rule when an item isn’t found is to negate that index and subtract 1. Therefore, we get –2–1, which is –3.

List<String> hex = Arrays.asList("30", "8", "3A", "FF");
  Collections.sort(hex);
  int x = Collections.binarySearch(hex, "8");
  int y = Collections.binarySearch(hex, "3A");
  int z = Collections.binarySearch(hex, "4F");
  System.out.println(x + " " + y + " " + z);
// 2 1 -3

When code compiles, it means that the Java compiler has checked the syntax and found no errors.If the code has any syntax errors or type mismatches, the compiler will produce compilation errors, and the code won't compile.
RUNTIME EXCEPTION: Even if the code compiles successfully, certain issues like accessing a null pointer, division by zero, or illegal argument types can cause the program to fail during execution, leading to a runtime exception.

List<Integer> ages = new ArrayList<>();
ages.add(Integer.parseInt("5"));   // Autoboxing: int 5 -> Integer 5
ages.add(Integer.valueOf("6"));    // No autoboxing: Integer 6 directly added
ages.add(7);                       // Autoboxing: int 7 -> Integer 7
ages.add(null);                    // No autoboxing: null directly added
for (int age : ages) System.out.print(age);  // Throws NullPointerException when trying to unbox null


 List<String> one = new ArrayList<String>();
  one.add("abc");
  List<String> two = new ArrayList<>();
  two.add("abc");
  if (one == two)
     System.out.println("A");
  else if (one.equals(two)) // works fro LIst too!!!

public void run(Integer[] ints, Double[] doubles) {
    List<Integer> intList = Arrays.asList(ints);  // Fixed-size list, cannot add/remove elements, but can modify
    List<Double> doubleList = List.of(doubles);   // Immutable list, cannot add/remove/modify elements
    // more code
}
!!NB!!
The List.of(array) method in Java is used to create an immutable list from the elements of the provided array. 
You cannot add, remove, or modify elements in the list after it is created.
Any attempt to modify the list (e.g., add, remove, set) will throw an UnsupportedOperationException.
The elements from the array are copied into the new list. This means the list is not backed by the array.
Changes to the original array will not affect the list, and changes to the list (if it were mutable, which it isn't) would not affect the original array.

String[] array = {"a", "b", "c"};
List<String> list = List.of(array);
System.out.println(list);  // Outputs: [a, b, c]
// Attempting to modify the list will throw an exception
list.add("d");  // Throws UnsupportedOperationException
List.of() does not allow null elements. If any element in the array is null, a NullPointerException will be thrown.
List.of() can also be used with varargs directly, like List.of("a", "b", "c"), which behaves similarly.

The Arrays.asList(ints) method in Java is used to create a fixed-size list backed by the specified array. Here's how it works:

Purpose:

Arrays.asList(ints) converts an array ints into a List. The resulting List is backed by the original array, meaning that changes to the list will reflect in the array and vice versa.
Fixed-Size List:

The list returned by Arrays.asList() is of fixed size. You cannot add or remove elements from this list.
If you try to call methods like add() or remove() on the resulting list, it will throw an UnsupportedOperationException.
Modifications:

You can modify the elements in the list (e.g., by using set()), and these changes will be reflected in the original array.
Similarly, changes made directly to the array will be reflected in the list.

Integer[] ints = {1, 2, 3};
List<Integer> intList = Arrays.asList(ints);

System.out.println(intList);  // Outputs: [1, 2, 3]

// Modifying the list
intList.set(0, 10);
System.out.println(Arrays.toString(ints));  // Outputs: [10, 2, 3]

// Modifying the array
ints[1] = 20;
System.out.println(intList);  // Outputs: [10, 20, 3]

// The following line would throw an UnsupportedOperationException
// intList.add(4);  // Uncommenting this will throw an exception
The List returned is not a typical ArrayList or LinkedList but a fixed-size view of the array, which lacks some of the flexibility of other list implementations.
Use Case:

Arrays.asList() is useful when you need a List view of an array, typically for use in APIs that require a List instead of an array.
Summary:
Arrays.asList(ints) creates a fixed-size list backed by the array ints.
You can modify elements within the list, and those changes will reflect in the original array.
You cannot add or remove elements from this list, and attempting to do so will throw an UnsupportedOperationException.


Aspect	      List (Interface)	                                                                       ArrayList (Class)
Type	         Interface	                                                                        Concrete Class
Instantiation	Cannot be instantiated directly	                                               Can be instantiated directly
Implementation	Abstract; must be implemented by a class	                         Implements List and provides a resizable array
Flexibility	Allows multiple implementations (e.g., LinkedList, ArrayList)	               Specific implementation of a list using an array
Usage	Used to define a list in a general way	                                                Used when a dynamic array is needed
Performance	Depends on the implementation	                                       Efficient for random access, slower for insertion/removal in the middle


List defines a general contract for lists, which can have multiple implementations.
It provides methods to add, remove, and access elements, among others.
Common Implementations:

ArrayList
LinkedList
Vector
Stack


Arrays.asList(), List, and ArrayList serve different purposes and have distinct characteristics.
Arrays.asList(ints) converts an array ints into a List. The resulting List is backed by the original array, meaning that changes to the list will reflect in the array and vice versa.
The list returned by Arrays.asList() is of fixed size. You cannot add or remove elements from this list.
If you try to call methods like add() or remove() on the resulting list, it will throw an UnsupportedOperationException.
The List returned is not a typical ArrayList or LinkedList but a fixed-size view of the array, which lacks some of the flexibility of other list implementations.
Arrays.asList() is useful when you need a List view of an array, typically for use in APIs that require a List instead of an array.
Arrays.asList(ints) creates a fixed-size list backed by the array ints.
You can modify elements within the list, and those changes will reflect in the original array.
You cannot add or remove elements from this list, and attempting to do so will throw an UnsupportedOperationException.



The Arrays.compare(s1, s2) method in Java is used to compare two arrays lexicographically (element by element) based on the natural ordering of the elements. It was introduced in Java 9 as part of the java.util.Arrays class.

Key Points:
Method Signature:

java
Copy code
public static int compare(T[] a, T[] b)
Parameters:
a - The first array to be compared.
b - The second array to be compared.
Returns:
An int value that indicates the result of the comparison:
0: If both arrays are equal (i.e., they contain the same elements in the same order).
Negative Value: If the first array is lexicographically less than the second array.
Positive Value: If the first array is lexicographically greater than the second array.

edge Cases:

Different Lengths: If the arrays have different lengths but the common prefix (the elements they share) is the same, the shorter array is considered to be lexicographically less than the longer array.
Null Arrays: If both arrays are null, they are considered equal (return 0). If one is null and the other is not, the null array is considered less.
Empty Arrays: Two empty arrays are considered equal.

String[] s1 = {"apple", "banana", "cherry"};
String[] s2 = {"apple", "banana", "date"};

int result = Arrays.compare(s1, s2);
System.out.println(result);  // Outputs a negative value because "cherry" < "date"

String[] s3 = {"apple", "banana", "cherry"};
String[] s4 = {"apple", "banana", "cherry"};

result = Arrays.compare(s3, s4);
System.out.println(result);  // Outputs 0 because both arrays are equal

String[] s5 = {"apple", "banana"};
String[] s6 = {"apple", "banana", "cherry"};

result = Arrays.compare(s5, s6);
System.out.println(result);  // Outputs a negative value because s5 is shorter


String[] s1 = { "Camel", "Peacock", "Llama"};  // s1: ["Camel", "Peacock", "Llama"]
String[] s2 = { "Camel", "Llama", "Peacock"};  // s2: ["Camel", "Llama", "Peacock"]
String[] s3 = { "Camel"};                      // s3: ["Camel"]
String[] s4 = { "Camel", null};                // s4: ["Camel", null]

// Arrays.compare(s1, s2) compares lexicographically
// Comparison starts with "Camel" == "Camel", then "Peacock" > "Llama"
// Hence, returns a positive integer because "Peacock" is lexicographically greater than "Llama"
int result1 = Arrays.compare(s1, s2);  // true: returns a positive integer

// Arrays.mismatch(s1, s2) finds the first mismatch
// The first mismatch is at index 1 ("Peacock" != "Llama")
// Hence, returns 1 (the index of the first mismatch)
int mismatch1 = Arrays.mismatch(s1, s2);  // false: returns 1 (not a positive integer but an index)

// Arrays.compare(s3, s4) compares lexicographically
// "Camel" == "Camel", but s4 has another element, so s3 is shorter
// Hence, returns a negative integer because s3 is shorter than s4
int result2 = Arrays.compare(s3, s4);  // false: returns a negative integer

// Arrays.mismatch(s3, s4) finds the first mismatch
// No mismatch at index 0, but s3 ends, while s4 has another element ("null")
// Hence, returns 1 (the index of the first mismatch)
int mismatch2 = Arrays.mismatch(s3, s4);  // true: returns a positive integer (index 1)

// Arrays.compare(s4, s4) compares lexicographically
// Both arrays are identical, so they are equal
// Hence, returns 0 because they are equal
int result3 = Arrays.compare(s4, s4);  // false: returns 0 (not a positive integer)

// Arrays.mismatch(s4, s4) finds the first mismatch
// Both arrays are identical, so no mismatch
// Hence, returns -1 because there is no mismatch
int mismatch3 = Arrays.mismatch(s4, s4);  // false: returns -1 (not a positive integer)

==========
LAMBDAS
==========
Invalid lambda

Reason

a, b -> a.startsWith("test")

Missing parentheses

a -> { a.startsWith("test"); }

Missing return

a -> { return a.startsWith("test") }

Missing semicolon
===================

There are four functional interfaces you are likely to see on the exam. The next sections take a look at Predicate, Consumer, Supplier, and Comparator.
===========
Luckily, Java recognizes that this is a common problem and provides such an interface for us. It’s in the package java.util.function and the gist of it is as follows:


public interface Predicate<T> {
   boolean test(T t);
}

:  import java.util.*;
2:  import java.util.function.*;
3:  public class PredicateSearch {
4:     public static void main(String[] args) {
5:        List<Animal> animals = new ArrayList<Animal>();
6:        animals.add(new Animal("fish", false, true));
7:          
8:        print(animals, a -> a.canHop());
9:     }
10:    private static void print(List<Animal> animals,
11:       Predicate<Animal>  checker) {
12:       for (Animal animal : animals) {
13:          if (checker.test(animal))
14:             System.out.print(animal + " ");
15:       }
16:       System.out.println();
17:    }
18: }
---------------

The Consumer functional interface has one method you need to know:


void accept(T t)
Why might you want to receive a value and not return it? A common reason is when printing a message:


Consumer<String> consumer = x -> System.out.println(x);
-------------------
public static void main(String[] args) {
   Consumer<String> consumer = x -> System.out.println(x);
   print(consumer, "Hello World");
}
private static void print(Consumer<String> consumer, String value) {
   consumer.accept(value);
}
--------------
The Supplier functional interface has only one method:


T get()
A good use case for a Supplier is when generating values. Here are two examples:


Supplier<Integer> number = () ->  42;
Supplier<Integer> random = () ->  new Random().nextInt();
The first example returns 42 each time the lambda is called. The second generates a random number each time it is called. It could be the same number but is likely to be a different one. After all, it’s random. Let’s take a look at code that uses a Supplier:


public static void main(String[] args) {
   Supplier<Integer> number = () ->  42;
   System.out.println(returnNumber(number));
}
 
private static int returnNumber(Supplier<Integer> supplier) {
   return supplier.get();
}
When the returnNumber() method is called, it invokes the lambda to get the desired value. In this case, the method returns 42.
-----------------------

Comparator
In Chapter 5, “Core Java APIs,” we compared numbers. We didn’t supply a Comparator because we were using the default sort order. We did learn the rules. A negative number means the first value is smaller, zero means they are equal, and a positive number means the first value is bigger. The method signature is as follows:


int compare(T o1, T o2)
This interface is a functional interface since it has only one unimplemented method. It has many static and default methods to facilitate writing complex comparators.

Note	
The Comparator interface existed prior to lambdas being added to Java. As a result, it is in a different package. You can find Comparator in java.util.

You only have to know compare() for the exam. Can you figure out whether this sorts in ascending or descending order?


Comparator<Integer> ints = (i1, i2) -> i1 - i2;
The ints comparator uses natural sort order. If the first number is bigger, it will return a positive number. Try it. Suppose we are comparing 5 and 3. The comparator subtracts 5-3 and gets 2. This is a positive number that means the first number is bigger and we are sorting in ascending order.

Let’s try another one. Do you think these two statements would sort in ascending or descending order?


Comparator<String> strings = (s1, s2) -> s2.compareTo(s1);
Comparator<String> moreStrings = (s1, s2) -> - s1.compareTo(s2);
Both of these comparators actually do the same thing: sort in descending order. In the first example, the call to compareTo() is “backwards,” making it descending. In the second example, the call uses the default order; however, it applies a negative sign to the result, which reverses it.

Be sure you understand Table 6.3 to identify what type of lambda you are looking at.
-------------------------------
Predicate<Integer> isEven = n -> n % 2 == 0;

System.out.println(isEven.test(4));  // Outputs: true
System.out.println(isEven.test(7));  // Outputs: false
----------------

Function<String, Integer> stringLength = str -> str.length();

System.out.println(stringLength.apply("Hello"));  // Outputs: 5
System.out.println(stringLength.apply("Java"));   // Outputs: 4
----------------------

Consumer<String> printUpperCase = str -> System.out.println(str.toUpperCase());

printUpperCase.accept("hello");  // Outputs: HELLO
printUpperCase.accept("java");   // Outputs: JAVA
-----------------------------

Supplier<Double> randomValue = () -> Math.random();

System.out.println(randomValue.get());  // Outputs a random number
System.out.println(randomValue.get());  // Outputs another random number
--------------------------

Comparator<String> lengthComparator = (str1, str2) -> Integer.compare(str1.length(), str2.length());

System.out.println(lengthComparator.compare("apple", "pear"));  // Outputs: 1 (because "apple" is longer than "pear")
System.out.println(lengthComparator.compare("apple", "banana"));  // Outputs: 0 (because both have the same length)
-------------------


Table 6.3: Basic functional interfaces
Functional interface

# parameters

Return type

Comparator

Two

int

Consumer

One

void

Predicate

One

boolean

Supplier

None

One

(type varies)

---------

Predicate<String> p = x -> true;
Predicate<String> p = (var x) -> true;
Predicate<String> p = (String x) -> true;

public void whatAmI() {
   consume((var x) -> System.out.print(x), 123);
}
public void consume(Consumer<Integer> c, int num) {
   c.accept(num);
}
============

(a, b) -> { int a = 0; return 5;}     // DOES NOT COMPILE
We tried to redeclare a, which is not allowed. 
=================

11: public void variables(int a) {
12:    int b = 1;
13:    Predicate<Integer> p1 = a -> {
14:       int b = 0;
15:       int c = 0;
16:       return b == c;}
17:    };
18: }

There are three syntax errors. The first is on line 13. The variable a was already used in this scope as a method parameter, so it cannot be reused. The next syntax error comes on line 14 where the code attempts to redeclare local variable b. The third syntax error is quite subtle and on line 16. See it? Look really closely.

The variable p1 is missing a semicolon at the end. There is a semicolon before the }, but that is inside the block. 
-----------------

public class Crow {
   private String color;
   public void caw(String name) {
      String volume = "loudly";
      Consumer<String> consumer = s ->
            System.out.println(name + " says "
                  + volume + " that she is " + color);
   }
}
Method parameters and local variables are allowed to be referenced if they are effectively final
In this example, name is not effectively final because it is set on line 6. However, the compiler error occurs on line 10. It’s not a problem to assign a value to a nonfinal variable. However, once the lambda tries to use it, we do have a problem. The variable is no longer effectively final, so the lambda is not allowed to use the variable.
The variable volume is not effectively final either since it is updated on line 12. In this case, the compiler error is on line 11. That’s before the assignment! Again, the act of assigning a value is only a problem from the point of view of the lambda. Therefore, the lambda has to be the one to generate the compiler error.

==========
: Rules for accessing a variable from a lambda body inside a method
Variable type

Rule

Instance variable

Allowed

Static variable

Allowed

Local variable

Allowed if effectively final

Method parameter

Allowed if effectively final

Lambda parameter

Allowed
================

List and Set declare a removeIf() method that takes a Predicate.

List<String> bunnies = new ArrayList<>();
4: bunnies.add("long ear");
5: bunnies.add("floppy");
6: bunnies.add("hoppy");
7: System.out.println(bunnies);     // [long ear, floppy, hoppy]
8: bunnies.removeIf(s -> s.charAt(0) != 'h');
9: System.out.println(bunnies);     // [hoppy]

The removeIf() method works the same way on a Set. It removes any values in the set that match the Predicate. There isn’t a removeIf() method on a Map.

While you can call Collections.sort(list), you can now sort directly on the list object.


3: List<String> bunnies = new ArrayList<>();
4: bunnies.add("long ear");
5: bunnies.add("floppy");
6: bunnies.add("hoppy");
7: System.out.println(bunnies);     // [long ear, floppy, hoppy]
8: bunnies.sort((b1, b2) -> b1.compareTo(b2));
9: System.out.println(bunnies);     // [floppy, hoppy, long ear]

Remember that Comparator takes two parameters and returns an int.
There is not a sort method on Set or Map.  Neither of those types has indexing,

Our final method is forEach(). It takes a Consumer and calls that lambda for each element encountered.
=======================
: List<String> bunnies = new ArrayList<>();
4: bunnies.add("long ear");
5: bunnies.add("floppy");
6: bunnies.add("hoppy");
7:
8: bunnies.forEach(b -> System.out.println(b));
9: System.out.println(bunnies);
===================
We can use forEach() with a Set or Map. For a Set, it works the same way as a List.


Set<String> bunnies = Set.of("long ear", "floppy", "hoppy");
bunnies.forEach(b -> System.out.println(b));
For a Map, you have to choose whether you want to go through the keys or values:


Map<String, Integer> bunnies =  new HashMap<>();
bunnies.put("long ear", 3);
bunnies.put("floppy", 8);
bunnies.put("hoppy", 1);
bunnies.keySet().forEach(b -> System.out.println(b));
bunnies.values().forEach(b -> System.out.println(b));
It turns out the keySet() and values() methods each return a Set. Since we know how to use forEach() with a Set, this is easy!
===========================


You don’t need to know this for the exam, but Java has a functional interface called BiConsumer. It works just like Consumer except it can take two parameters. This functional interface allows you to use forEach() with key/value pairs from Map.


Map<String, Integer> bunnies = new HashMap<>();
bunnies.put("long ear", 3);
bunnies.put("floppy", 8);
bunnies.put("hoppy", 1);
bunnies.forEach((k, v) -> System.out.println(k + " " + v));
=====================

(String a, String b) -> { return a.equals(b); }
==============
Consumer takes any type and doesn’t return a value. Supplier returns a value and does not take any parameters. Comparator takes two parameters and returns an int.
==============
We covered three common APIs that use lambdas. The removeIf() method on a List and a Set takes a Predicate. The sort() method on a List interface takes a Comparator. The forEach() methods on a List and a Set interface both take a Consumer.
===============

 interface Climb {
        boolean isTooHigh(int height, int limit);
    }

    public class Climber {
        public static void main(String[] args) {
            check((h, m) -> h.append(m).isEmpty(), 5);
        }

        private static void check(Climb climb, int height) {
            if (climb.isTooHigh(height, 10))
                System.out.println("too high");
            else
                System.out.println("ok");
        }
    }
The lambda is supposed to implement the isTooHigh method of the Climb interface.

!! NB !!
map.keySet()

map.values() BOTH RETURN A SET, SO CAN BE USED WITH 1 PARAM:
 Map map = Map.of(1, 2, 3, 4);
  _______.forEach(x -> System.out.println(x));
==================================

!! NB !!
The Consumer interface is best for printing out an existing value.: TRUE
The Supplier interface is best for printing out an existing value: FALSE
The Comparator interface returns an int.: TRUE
The Predicate interface has a method named test().: TRUE
++++++++++++++

the values parameter in the method void changeDiscountValues(Object... values); can accept a combination of different types, including double and int.

Explanation:
Varargs (Object...): The ellipsis (...) in the parameter list indicates that the method can accept a variable number of arguments. These arguments are treated as an array of Object inside the method.

Accepting Multiple Types: Since the parameter is of type Object, it can accept any type of argument, including primitives like double and int, as they will be autoboxed into their corresponding wrapper types (Double and Integer).

Example:
java
Copy code
changeDiscountValues(10.5, 15.2, 20, 30);  // valid: (Double, Double, Integer, Integer)
========================


Polders zijn een essentieel kenmerk van het Nederlandse landschap, en ze spelen een cruciale rol in het beheer van water en landbouw. Een polder is een stuk land dat is ingepolderd, wat betekent dat het kunstmatig droog is gelegd door het waterpeil te beheersen met behulp van dijken, sluizen en gemalen. Nederland heeft meer dan 3000 polders, wat neerkomt op ongeveer 20% van het totale landoppervlak van het land.

Een interessant feit is dat de Achtermeer, de oudste polder in Nederland, in 1533 werd drooggelegd. Deze polder ligt in de provincie Noord-Holland, nabij Alkmaar. De Achtermeer was ongeveer 800 vierkante m groot.
Een ander opmerkelijk aspect is dat de beroemde Flevopolder, gelegen in de provincie Flevoland, de grootste kunstmatige polder ter wereld is. Deze polder werd in 1968 voltooid en heeft een oppervlakte van ongeveer 970 vierkante kilometer.

Wist je dat Nederland ook een van de laagst gelegen landen ter wereld is? Een groot deel van Nederland ligt onder de zeespiegel, met de laagste punt in de gemeente Zuidplas, die 6,76 meter onder NAP (Normaal Amsterdams Peil) ligt. Dankzij de polders en de waterbeheerstructuren, zoals dijken en gemalen, kunnen miljoenen mensen veilig wonen en werken in deze gebieden. Bovendien hebben sommige polders, zoals de Beemsterpolder, een plek op de UNESCO Werelderfgoedlijst gekregen vanwege hun unieke historische en culturele waarde

	'blussenbrand - put out(Fire, brand)

landbow - aggriculture, waterpeil-waterlevel, gemalen - pumping stations

hooft zin, bijzin(klaare taal)
want : omdat, als, toen, naadat, voordat, opdat, hoewel, ofschoon, mits, tenzji
terwijl, dat, waneer, om, dan is het beter : het strand( bijwoorden)
werkwoord - verb

en maar want of - hooft zin: voorgoorde veranderd sich niet========
=========
ER WAS...
er, hij, het was
er - onbepaald
er was net iemand aan de deur: net verleden tijd, just
Ga er maar aanstaan - Just try it" or "Go ahead and try it
======================
iets voor Bulgarije met google earth! - 200 woorden
bullet points == GOOGLE EARTH, EEN GEHEIM, WAAR TOURISTEN NIET GAAN

==================
kingdom - japanese movie sequel 4
----------

Lambdas are only allowed to reference effectively final variables.
======================

!! NB !!
 List<String> cats = new ArrayList<>();
  cats.add("leo");
  cats.add("Olivia");
cats.sort((c1, c2) -> -c1.compareTo(c2)); is sorting the list of strings in reverse lexicographical order. capital letters are b4 small, so reversed is: [leo, Olivia]
the code correctly sorts in descending order. Since uppercase normally sorts before lowercase, the order is reversed here,
============================

Lambdas are only allowed to reference effectively final variables.
====================

Which of the following can be inserted without causing a compilation error? (Choose all that apply.)


  public void remove(List<Character> chars) {
     char end = 'z';
     // INSERT LINE HERE
     chars.removeIf(c -> {
        char start = 'a'; return start <= c && c <= end; });
  }
char start = 'a';

char c = 'x';

chars = null;

end = '1';

None of the above

Answer:
C. Lambdas are not allowed to redeclare local variables, making options A and B incorrect. Option D is incorrect because setting end prevents it from being effectively final. Lambdas are only allowed to reference effectively final variables. Option C is tricky because it does compile but throws an exception at runtime. Since the question only asks about compilation, option C is correct.
============

HashSet() in Java is a constructor used to create an instance of the HashSet class, which is part of the Java Collections Framework. A HashSet is a collection that implements the Set interface and is backed by a hash table (actually a HashMap instance). It is used to store unique elements, meaning it does not allow duplicate values.

Key Characteristics of HashSet:
No Duplicates: HashSet does not allow duplicate elements. If you try to add a duplicate element, the set will ignore it.

Unordered: The elements in a HashSet are not ordered. The order of elements can change over time, especially as new elements are added or existing elements are removed.

Allows Null: HashSet allows one null element.

Fast Operations: The operations such as add, remove, and contains typically have constant time complexity, O(1), due to the underlying hash table.
 the output may not match the order in which the els were added.
Set is not an ordered Collection. 
==================
!! NB !!
Method parameters and local variables are effectively final if they aren’t changed after initialization
========

public class Panda {
  4:     int age;
  5:     public static void main(String[] args) {
  6:        Panda p1 = new Panda();
  7:        p1.age = 1;
  8:        check(p1, p -> {p.age < 5});
  9:     }
  10:    private static void check(Panda panda,
  11:       Predicate<Panda> pred) {
  12:       String result = pred.test(panda)
  13:          ? "match" : "not match";
  14:       System.out.print(result);
  15: } }
C. Line 8 uses braces around the body. This means the return keyword and semicolon are required.
===================


 Set<String> s = Set.of("mickey", "minnie");
  List<String> x = new ArrayList<>(s);

  s.forEach(s -> System.out.println(s));
  x.forEach(x -> System.out.println(x));
Lambda parameters are not allowed to use the same name as another variable in the same scope.

================


Predicate<String> type? (Choose all that apply.)

s -> s.isEmpty()
=========

CLASSES

=================

Default (Package-Private) Access With default access, the method can be called only from classes in the same package. This one is tricky because there is no keyword for default access. You simply omit the access modifier.

protected The protected modifier means the method can be called only from classes in the same package or subclasses. 

THOSE COMPILE:
public void walk2() { return; }
public String walk3() { return ""; }

int longMethod() {
   return 9L; // DOES NOT COMPILE
}
int longExpanded() {
   int temp = 9L; // DOES NOT COMPILE
   return temp;
}

 You can list as many types of exceptions as you want in this clause separated by commas.
public void oneException() throws IllegalArgumentException {}
public void twoExceptions() throws
   IllegalArgumentException, InterruptedException {}

====================

A varargs parameter must be the last element in a method’s parameter list. 
public void walk4(int... start, int... nums) {} // DOES NOT COMPILE


When calling a method with a varargs parameter, you have a choice. You can pass in an array, or you can list the elements of the array and let Java create it for you. You can even omit the varargs values in the method call and Java will create an array of length zero for you.


15: public static void walk(int start, int... nums) {
16:    System.out.println(nums.length);
17: }
18: public static void main(String[] args) {
19:    walk(1);                       // 0
20:    walk(1, 2);                    // 1
21:    walk(1, 2, 3);                 // 2
22:    walk(1, new int[] {4, 5});     // 2
23: }

You’ve seen that Java will create an empty array if no parameters are passed for a vararg. However, it is still possible to pass null explicitly:


walk(1, null);     // throws a NullPointerException in walk()
Since null isn’t an int, Java treats it as an array reference that happens to be null. It just passes on the null array object to walk. Then the walk() method throws an exception because it tries to determine the length of null.

16: public static void run(int... nums) {
17:    System.out.println(nums[1]);
18: }
19: public static void main(String[] args) {
20:    run(11, 22);     // 22
21: }
==============



package pond.duck;
public class MotherDuck {
   String noise = "quack";
   void quack() {
      System.out.println(noise);     // default access is ok
   }
   private void makeNoise() {
      quack();                       // default access is ok
   }
}
MotherDuck can refer to noise and call quack(). After all, members in the same class are certainly in the same package. The big difference is MotherDuck lets other classes in the same package access members (due to being package-private), whereas FatherDuck doesn’t (due to being private). GoodDuckling has a much better experience than BadDuckling:


package pond.duck;
public class GoodDuckling {
   public void makeNoise() {
      MotherDuck duck = new MotherDuck();
      duck.quack();                            // default access
      System.out.println(duck.noise);          // default access
   }
}
=======


package pond.swan;
import pond.duck.MotherDuck;              // import another package
public class BadCygnet {
   public void makeNoise() {
      MotherDuck duck = new MotherDuck();
      duck.quack();                       // DOES NOT COMPILE
      System.out.println(duck.noise);     // DOES NOT COMPILE    
   }
}
 MotherDuck has default: no access modifiers for String noise='quak' and the method

============
1:  package pond.swan;
2:  import pond.shore.Bird;     // in different package than Bird
3:  public class Swan extends Bird {     // but subclass of Bird
4:     public void swim() {
5:        floatInWater();              // subclass access to superclass
6:        System.out.println(text);    // subclass access to superclass
7:     }
8:     public void helpOtherSwanSwim() {
9:        Swan other = new Swan();
10:       other.floatInWater();        // subclass access to superclass
11:       System.out.println(other.text);  // subclass access
12:                                        // to superclass
13:    }
14:    public void helpOtherBirdSwim() {
15:       Bird other = new Bird();
16:       other.floatInWater();               // DOES NOT COMPILE
17:       System.out.println(other.text);     // DOES NOT COMPILE
18:    }
19: }

This time a Bird reference is used rather than inheritance. It is created on line 15. Bird is in a different package, and this code isn’t inheriting from Bird, so it doesn’t get to use protected members. Say what now? We just got through saying repeatedly that Swan inherits from Bird. And it does. However, the variable reference isn’t a Swan. The code just happens to be in the Swan class.


A member is used without referring to a variable. This is the case on lines 5 and 6. In this case, we are taking advantage of inheritance and protected access is allowed.

A member is used through a variable. This is the case on lines 10, 11, 16, and 17. In this case, the rules for the reference type of the variable are what matter. If it is a subclass, protected access is allowed. This works for references to the same class or a subclass.
package pond.goose;
import pond.shore.Bird;
public class Goose extends Bird {
   public void helpGooseSwim() {
      Goose other = new Goose();
      other.floatInWater();
      System.out.println(other.text);
   }
   public void helpOtherGooseSwim() {
      Bird other = new Goose();
      other.floatInWater();           // DOES NOT COMPILE
      System.out.println(other.text); // DOES NOT COMPILE
   }
}

== STATIC ===

public class Koala {
   public static int count = 0;               // static variable
   public static void main(String[] args) {   // static method
      System.out.println(count);
   }
}
Here the JVM basically calls Koala.main() to get the program started. You can do this too. We can have a KoalaTester that does nothing but call the main() method:


public class KoalaTester {
   public static void main(String[] args) {
      Koala.main(new String[0]);          // call static method
   }
}

!! nb !!

5: Koala k = new Koala();
6: System.out.println(k.count);          // k is a Koala
7: k = null;
8: System.out.println(k.count);          // k is still a Koala
Believe it or not, this code outputs 0 twice. Line 6 sees that k is a Koala and count is a static variable, so it reads that static variable. Line 8 does the same thing. Java doesn’t care that k happens to be null. Since we are looking for a static, it doesn’t matter.

The exam creators will try to trick you into thinking a NullPointerException is thrown because the variable happens to be null. Don’t be fooled!

Accessing count using k.count works because static variables can be accessed through an instance reference, though it's more common to access them via the class name (e.g., Koala.count).

k = null;
The reference k is now set to null, meaning it no longer points to the Koala object. However, the Koala class still exists, and static variables of the class remain accessible.

Koala.count = 4;
Koala koala1 = new Koala();
Koala koala2 = new Koala();
koala1.count = 6;
koala2.count = 5;
System.out.println(Koala.count);
We hope you answered 5. There is only one count variable since it is static. It is set to 4, then 6, and finally winds up as 5. All the Koala variables are just distractions.


public class Static {
   private String name = "Static class";
   public static void first() {  }
   public static void second() {  }
   public void third() {  System.out.println(name); }
   public static void main(String args[]) {
      first();
      second();
      third();          // DOES NOT COMPILE
   }
}
The compiler will give you an error about making a static reference to a nonstatic method. If we fix this by adding static to third(), we create a new problem

A static method or instance method can call a static method because static methods don’t require an object to use. Only an instance method can call another instance method on the same class without using a reference variable, because instance methods do require an object. Similar logic applies for the instance and static variables.



!!! NB !!!
1:  public class Gorilla {
2:     public static int count;
3:     public static void addGorilla() { count++; }
4:     public void babyGorilla() { count++; }
5:     public void announceBabies() {
6:        addGorilla();
7:        babyGorilla();
8:     }
9:     public static void announceBabiesToEveryone() {
10:       addGorilla();
11:       babyGorilla();     // DOES NOT COMPILE
12:    }
13:    public int total;
14:    public static double average
15:       = total / count;  // DOES NOT COMPILE
16: }
Lines 3 and 4 are fine because both static and instance methods can refer to a static variable. Lines 5–8 are fine because an instance method can call a static method. Line 11 doesn’t compile because a static method cannot call an instance method. Similarly, line 15 doesn’t compile because a static variable is trying to use an instance variable.

A common use for static variables is counting the number of instances:


public class Counter {
   private static int count;
   public Counter() { count++; }
   public static void main(String[] args) {
      Counter c1 = new Counter();
      Counter c2 = new Counter();
      Counter c3 = new Counter();
      System.out.println(count);          // 3
   }
}

Each time the constructor gets called, it increments count by 1. This example relies on the fact that static (and instance) variables are automatically initialized to the default value for that type, which is 0 for int. See Chapter 2 to review the default values.

Also notice that we didn’t write Counter.count. We could have. It isn’t necessary because we are already in that class so the compiler can infer it.


public class Initializers {
   private static final int NUM_BUCKETS = 45;
   public static void main(String[] args) {
      NUM_BUCKETS = 5;  // DOES NOT COMPILE
   }
}

private static final ArrayList<String> values = new ArrayList<>();
public static void main(String[] args) {
   values.add("changed");
}
It actually does compile since values is a reference variable. We are allowed to call methods on reference variables. All the compiler can do is check that we don’t try to reassign the final values to point to a different object.


==============

14: private static int one;
15: private static final int two;
16: private static final int three = 3;
17: private static final int four;    // DOES NOT COMPILE
18: static {
19:    one = 1;
20:    two = 2;
21:    three = 3;                     // DOES NOT COMPILE
22:    two = 4;                       // DOES NOT COMPILE
23: }

Line 17 declares a final variable that never gets initialized. The compiler gives a compiler error because it knows that the static blocks are the only place the variable could possibly get initialized.

1: import static java.util.Arrays;       // DOES NOT COMPILE
2: import static java.util.Arrays.asList;
3: static import java.util.Arrays.*;     // DOES NOT COMPILE
4: public class BadStaticImports {
5:    public static void main(String[] args) {
6:       Arrays.asList("one");           // DOES NOT COMPILE
7:    } }
Line 1 tries to use a static import to import a class. Remember that static imports are only for importing static members. Regular imports are for importing a class. Line 3 tries to see whether you are paying attention to the order of keywords. The syntax is import static and not vice versa. Line 6 is sneaky. The asList method is imported on line 2. However, the Arrays class is not imported anywhere. This makes it okay to write asList("one") but not Arrays.asList("one").

There’s only one more scenario with static imports. In Chapter 1, you learned that importing two classes with the same name gives a compiler error. This is true of static imports as well. The compiler will complain if you try to explicitly do a static import of two methods with the same name or two static variables with the same name. Here’s an example:


import static statics.A.TYPE;
import static statics.B.TYPE;     // DOES NOT COMPILE

==============
Method overloading occurs when methods have the same name but different method signatures, which means they differ by method parameters. (Overloading differs from overriding, 
These are all valid overloaded methods:


public void fly(int numMiles) {}
public void fly(short numFeet) {}
public boolean fly() { return false; }
void fly(int numMiles, short numFeet) {}
public void fly(short numFeet, int numMiles) throws Exception {}































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































============

































































































































































































































































































































































































































































































